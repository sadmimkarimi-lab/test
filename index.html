<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>عنوان کتاب شما</title>

  <!-- فونت وزیر -->
  <link href="https://cdn.jsdelivr.net/gh/rastikerdar/vazir-font@v30.1.0/dist/font-face.css" rel="stylesheet" />

  
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Vazir, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5; /* پس‌زمینه روشن */
      color: #111827;      /* متن مشکی/تیره */
    }

    .page {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px 16px 40px;
    }

    /* هدر / کاور کتاب */
    .hero {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }

    .hero-cover {
      width: 180px;                 /* عرض قاب */
      aspect-ratio: 464 / 600;      /* نسبت واقعی جلد */
      border-radius: 16px;
      overflow: hidden;
      background: #e5e7eb;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.2);
      flex-shrink: 0;
    }

    .hero-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;            /* بدون کشیدگی */
    }

    .hero-text {
      flex: 1;
      min-width: 200px;
    }

    .hero-text h1 {
      margin: 0 0 8px;
      font-size: 24px;
    }

    .hero-text p {
      margin: 0;
      font-size: 14px;
      color: #4b5563;
      line-height: 1.9;
    }

    /* فهرست کلی */
    .toc {
      background: #ffffff;
      border-radius: 18px;
      padding: 16px 14px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      margin-bottom: 24px;
      border: 1px solid #e5e7eb;
    }

    .toc h2 {
      margin: 0 0 12px;
      font-size: 18px;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 6px;
    }

    .toc-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .toc-chapter {
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px dashed #e5e7eb;
    }

    .toc-chapter:last-child {
      border-bottom: none;
    }

    .toc-chapter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 6px 2px;
    }

    .toc-chapter-title {
      font-size: 15px;
      font-weight: 600;
    }

    .toc-chapter-toggle {
      font-size: 18px;
      line-height: 1;
      user-select: none;
      color: #6b7280;
    }

    .toc-section-list {
      list-style: none;
      padding: 4px 8px 4px 0;
      margin: 0;
      display: none;
    }

    .toc-chapter.open .toc-section-list {
      display: block;
    }

    .toc-section-item {
      margin-bottom: 4px;
    }

    .toc-btn {
      width: 100%;
      text-align: right;
      border: none;
      background: transparent;
      color: #111827;
      padding: 6px 6px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 999px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .toc-btn span {
      flex: 1;
    }

    .toc-btn small {
      font-size: 11px;
      color: #9ca3af;
      white-space: nowrap;
    }

    .toc-btn:hover {
      background: #f3f4f6;
    }

    .toc-btn.active {
      background: #111827;
      color: #f9fafb;
    }

    /* فصل‌ها و متن */
    .chapters {
      margin-top: 10px;
    }

    .chapter {
      background: #ffffff;
      border-radius: 18px;
      padding: 14px 14px 10px;
      margin-bottom: 14px;
      border: 1px solid #e5e7eb;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.04);
    }

    .chapter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .chapter-title {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
    }

    .chapter-toggle {
      font-size: 18px;
      line-height: 1;
      user-select: none;
      color: #6b7280;
    }

    .chapter-body {
      margin-top: 10px;
      font-size: 14px;
      color: #111827;
      line-height: 2;
      display: none; /* اول بسته */
      max-height: 65vh;
      overflow-y: auto;
      padding-top: 4px;
      border-top: 1px solid #e5e7eb;
    }

    .chapter.active .chapter-body {
      display: block;
    }

    .section {
      margin-bottom: 18px;
    }

    .section-title {
      font-size: 15px;
      margin: 0 0 6px;
      font-weight: 600;
    }

    .section p {
      margin: 0 0 8px;
      text-align: justify;
    }

    @media (max-width: 600px) {
      .hero {
        flex-direction: row;
        align-items: flex-start;
      }

      /* فقط عرض رو کوچیک می‌کنیم، height رو دست نمی‌زنیم */
      .hero-cover {
        width: 150px;
      }

      .hero-text h1 {
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="page">

    <!-- هدر و کاور کتاب -->
    <header class="hero">
      <div class="hero-cover">
        <!-- عکس جلد کتاب -->
        <img src="https://cdnfa.com/irangiah/a9be/uploads/ketab/propm.webp" alt="جلد کتاب">
      </div>

      <div class="hero-text">
        <h1>عنوان کتاب شما</h1>
        <p>
          اینجا یک توضیح کوتاه درباره کتاب می‌نویسی؛ مثلاً موضوع کلی، مخاطب کتاب
          و این‌که قرار است خواننده چه چیزی از این کتاب بگیرد.
        </p>
      </div>
    </header>

    <!-- فهرست: فصل‌ها + مبحث‌ها -->
    <section class="toc">
      <h2>فهرست</h2>
      <ul class="toc-list">

        <!-- فصل اول -->
<li class="toc-chapter" data-chapter="chapter-1">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل اول: پرامپت‌نویسی چیست و مدل چگونه کار می‌کند؟</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>
  <ul class="toc-section-list">
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-1"
              data-section="section-1-1">
        <span>مبحث ۱: مقدمه – پرامپت و نقش آن</span>
        <small>صفحات ۶–۷</small>
      </button>
    </li>
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-1"
              data-section="section-1-2">
        <span>مبحث ۲: مدل‌های زبانی چگونه پاسخ می‌سازند؟</span>
        <small>صفحات ۷–۹</small>
      </button>
    </li>
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-1"
              data-section="section-1-3">
        <span>مبحث ۳: پرامپت‌نویسی یعنی طراحی یک مسیر واضح</span>
        <small>صفحات ۹–۱۰</small>
      </button>
    </li>
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-1"
              data-section="section-1-4">
        <span>مبحث ۴: تنظیمات مدل و کنترل خروجی</span>
        <small>تقریباً صفحات ۱۰–۱۳</small>
      </button>
    </li>
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-1"
              data-section="section-1-5">
        <span>مبحث ۵: جمع‌بندی فصل اول</span>
        <small>مرور کلی</small>
      </button>
    </li>
  </ul>
</li>

        <!-- فصل دوم -->
<li class="toc-chapter" data-chapter="chapter-2">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل دوم: تکنیک‌های پرامپت‌نویسی</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>
  <ul class="toc-section-list">
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-1">
        <span>مبحث ۱: Zero-shot Prompting</span>
        <small>صفحات ۱۳–۱۴</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-2">
        <span>مبحث ۲: One-shot & Few-shot</span>
        <small>صفحات ۱۵–۱۸</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-3">
        <span>مبحث ۳: System Prompting</span>
        <small>صفحات ۱۸–۲۱</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-4">
        <span>مبحث ۴: Role Prompting</span>
        <small>صفحات ۲۱–۲۳</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-5">
        <span>مبحث ۵: Contextual Prompting</span>
        <small>صفحات ۲۳–۲۵</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-6">
        <span>مبحث ۶: جمع‌بندی فصل دوم</span>
        <small>مرور</small>
      </button>
    </li>
  </ul>
</li>

        <!-- فصل سوم -->
<li class="toc-chapter" data-chapter="chapter-3">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل سوم: تکنیک‌های استدلال و تولید پاسخ هوشمند</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>
  <ul class="toc-section-list">
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-1">
        <span>مبحث ۱: مقدمه – چرا به استدلال نیاز داریم؟</span>
        <small>شروع فصل</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-2">
        <span>مبحث ۲: Step-back Prompting</span>
        <small>صفحات ۲۵–۲۷</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-3">
        <span>مبحث ۳: Chain-of-Thought (زنجیرهٔ تفکر)</span>
        <small>صفحات ۲۷–۳۰</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-4">
        <span>مبحث ۴: Self-consistency reasoning</span>
        <small>صفحات ۳۰–۳۲</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-5">
        <span>مبحث ۵: Tree-of-Thought</span>
        <small>صفحات ۳۲–۳۴</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-6">
        <span>مبحث ۶: Deliberate Prompting</span>
        <small>صفحات ۳۴–۳۵</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-7">
        <span>مبحث ۷: جمع‌بندی فصل سوم</span>
        <small>مرور</small>
      </button>
    </li>
  </ul>
</li>

        <!-- فصل چهارم -->
<li class="toc-chapter" data-chapter="chapter-4">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل چهارم: تکنیک‌های ساختاردهی خروجی</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>
  <ul class="toc-section-list">
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-1">
        <span>مبحث ۱: مقدمه – چرا ساختار مهم است؟</span>
        <small>شروع فصل</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-2">
        <span>مبحث ۲: Specification Prompting</span>
        <small>صفحات ۳۵–۳۸</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-3">
        <span>مبحث ۳: Format Prompting</span>
        <small>صفحات ۳۸–۴۳</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-4">
        <span>مبحث ۴: Pointwise Prompting</span>
        <small>صفحات ۴۳–۴۶</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-5">
        <span>مبحث ۵: Instruction Hierarchy</span>
        <small>صفحات ۴۶–۴۸</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-6">
        <span>مبحث ۶: Rewriting Prompts</span>
        <small>صفحات ۴۸–۵۰</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-7">
        <span>مبحث ۷: Multi-turn Formatting</span>
        <small>صفحات ۵۰–۵۲</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-8">
        <span>مبحث ۸: جمع‌بندی فصل چهارم</span>
        <small>مرور</small>
      </button>
    </li>
  </ul>
</li>

<!-- فصل پنجم -->
<li class="toc-chapter" data-chapter="chapter-5">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل پنجم: خطاها، محدودیت‌ها و کنترل کیفیت مدل</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>

  <ul class="toc-section-list">

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-1">
        <span>مبحث ۱: مقدمه – چرا کنترل کیفیت ضروری است؟</span>
        <small>شروع فصل</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-2">
        <span>مبحث ۲: محدودیت‌های مدل</span>
        <small>صفحات ۵۲–۵۴</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-3">
        <span>مبحث ۳: Hallucination – اطلاعات ساختگی</span>
        <small>صفحات ۵۴–۵۶</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-4">
        <span>مبحث ۴: تکنیک‌های کاهش خطا</span>
        <small>صفحات ۵۶–۶۰</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-5">
        <span>مبحث ۵: Safety و محتوای ممنوع</span>
        <small>صفحات ۶۰–۶۲</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-6">
        <span>مبحث ۶: Verification – راستی‌آزمایی خروجی</span>
        <small>صفحات ۶۲–۶۴</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-7">
        <span>مبحث ۷: Grounding – اتصال به واقعیت</span>
        <small>صفحات ۶۴–۶۶</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-8">
        <span>مبحث ۸: Guardrails – ریل‌های محافظتی</span>
        <small>صفحات ۶۶–۶۷</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-9">
        <span>مبحث ۹: Self-checking – بررسی و اصلاح توسط مدل</span>
        <small>صفحات ۶۷–۶۸</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-10">
        <span>مبحث ۱۰: جمع‌بندی فصل پنجم</span>
        <small>مرور</small>
      </button>
    </li>

  </ul>
</li>

<!-- فصل ششم -->
<li class="toc-chapter" data-chapter="chapter-6">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل ششم: ReAct و مهندسی پرامپت خودکار</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>

  <ul class="toc-section-list">

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-6"
        data-section="section-6-1">
        <span>مبحث ۱: مقدمه – ورود به عصر Agentها</span>
        <small>شروع فصل</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-6"
        data-section="section-6-2">
        <span>مبحث ۲: ReAct چیست؟ ترکیب Reason + Act</span>
        <small>صفحات 37–39</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-6"
        data-section="section-6-3">
        <span>مبحث ۳: ساختار کلی ReAct</span>
        <small>چرخه Think → Act → Observe</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-6"
        data-section="section-6-4">
        <span>مبحث ۴: چه زمانی از ReAct استفاده کنیم؟</span>
        <small>کاربردهای واقعی</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-6"
        data-section="section-6-5">
        <span>مبحث ۵: مزایای ReAct</span>
        <small>دقت، کاهش خطا، تحلیل چندمرحله‌ای</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-6"
        data-section="section-6-6">
        <span>مبحث ۶: Automatic Prompt Engineering (APE)</span>
        <small>صفحه 40</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-6"
        data-section="section-6-7">
        <span>مبحث ۷: کاربردهای APE</span>
        <small>ربات‌های هوشمند و سیستم‌های پیچیده</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-6"
        data-section="section-6-8">
        <span>مبحث ۸: جمع‌بندی فصل ششم</span>
        <small>مرور</small>
      </button>
    </li>

  </ul>
</li>
        
<!-- فصل هفتم -->
<li class="toc-chapter" data-chapter="chapter-7">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل هفتم: مهندسی پرامپت برای کدنویسی</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>

  <ul class="toc-section-list">

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-7"
        data-section="section-7-1">
        <span>مبحث ۱: مقدمه – چرا Code Prompting مهم است؟</span>
        <small>شروع فصل</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-7"
        data-section="section-7-2">
        <span>مبحث ۲: Comment-to-Code Prompting</span>
        <small>صفحات ۴۲–۴۴</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-7"
        data-section="section-7-3">
        <span>مبحث ۳: Code Explanation Prompt</span>
        <small>صفحات ۴۴–۴۶</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-7"
        data-section="section-7-4">
        <span>مبحث ۴: Translating Code Between Languages</span>
        <small>صفحات ۴۶–۴۷</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-7"
        data-section="section-7-5">
        <span>مبحث ۵: Debugging Prompting</span>
        <small>صفحات ۴۷–۴۹</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-7"
        data-section="section-7-6">
        <span>مبحث ۶: Refactoring (بازنویسی تمیز کد)</span>
        <small>صفحات ۴۹–۵۱</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-7"
        data-section="section-7-7">
        <span>مبحث ۷: Writing Tests و Documentation</span>
        <small>صفحات ۵۱–۵۲ و بعد</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-7"
        data-section="section-7-8">
        <span>مبحث ۸: Architecture & File Planning</span>
        <small>طراحی ساختار پروژه</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-7"
        data-section="section-7-9">
        <span>مبحث ۹: جمع‌بندی فصل هفتم</span>
        <small>مرور</small>
      </button>
    </li>

  </ul>
</li>


<!-- فصل هشتم -->
<li class="toc-chapter" data-chapter="chapter-8">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل هشتم: پرامپت‌های چندرسانه‌ای</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>

  <ul class="toc-section-list">

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-8" data-section="section-8-1">
        <span>مبحث ۱: مقدمه – آشنایی با چندرسانه‌ای</span>
        <small>شروع فصل</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-8" data-section="section-8-2">
        <span>مبحث ۲: چندرسانه‌ای یعنی چه؟</span>
        <small>تعریف + مثال‌ها</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-8" data-section="section-8-3">
        <span>مبحث ۳: Image-to-Text Prompting</span>
        <small>تحلیل و توضیح عکس</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-8" data-section="section-8-4">
        <span>مبحث ۴: Image-to-Code Prompting</span>
        <small>تبدیل UI به کد</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-8" data-section="section-8-5">
        <span>مبحث ۵: Document & PDF Prompting</span>
        <small>تحلیل فایل‌ها و PDF</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-8" data-section="section-8-6">
        <span>مبحث ۶: Audio Prompting</span>
        <small>تحلیل و تبدیل صوت</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-8" data-section="section-8-7">
        <span>مبحث ۷: Video Prompting</span>
        <small>تجزیه‌و‌تحلیل ویدیو</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-8" data-section="section-8-8">
        <span>مبحث ۸: Multimodal Reasoning</span>
        <small>استدلال چندحسی</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-8" data-section="section-8-9">
        <span>مبحث ۹: Multimodal Generation</span>
        <small>تولید چندرسانه‌ای</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-8" data-section="section-8-10">
        <span>مبحث ۱۰: قالب‌های عملی (Templates)</span>
        <small>پرامپت‌های آماده</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-8" data-section="section-8-11">
        <span>مبحث ۱۱: جمع‌بندی فصل هشتم</span>
        <small>مرور نهایی</small>
      </button>
    </li>

  </ul>
</li>

        <!-- فصل نهم -->
<li class="toc-chapter" data-chapter="chapter-9">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل نهم: بهترین شیوه‌های پرامپت‌نویسی</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>

  <ul class="toc-section-list">

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-9" data-section="section-9-1">
        <span>مبحث ۱: مقدمه – فصل قوانین طلایی</span>
        <small>صفحات 60–66</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-9" data-section="section-9-2">
        <span>مبحث ۲: اصل شفافیت (Clarity)</span>
        <small>پرامپت واضح و بدون ابهام</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-9" data-section="section-9-3">
        <span>مبحث ۳: اصل ساده‌سازی (Simplicity)</span>
        <small>کوتاه، تمیز، بدون شلوغی</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-9" data-section="section-9-4">
        <span>مبحث ۴: اصل ساختاردهی (Structure)</span>
        <small>قالب، بخش‌بندی، فرمت خروجی</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-9" data-section="section-9-5">
        <span>مبحث ۵: اصل مثال‌دادن (Use Examples)</span>
        <small>Few-shot به‌جای Zero-shot</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-9" data-section="section-9-6">
        <span>مبحث ۶: اصل کنترل خروجی (Output Constraints)</span>
        <small>طول، لحن، فرمت، محدودیت‌ها</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-9" data-section="section-9-7">
        <span>مبحث ۷: ارزیابی، اصلاح و تکرار</span>
        <small>Evaluate → Improve → Iterate</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-9" data-section="section-9-8">
        <span>مبحث ۸: ۱۰ اصل طلایی Tavita</span>
        <small>چک‌لیست ویژهٔ الهه</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-9" data-section="section-9-9">
        <span>مبحث ۹: جمع‌بندی فصل نهم</span>
        <small>مرور نهایی Best Practices</small>
      </button>
    </li>

  </ul>
</li>


<!-- فصل دهم -->
<li class="toc-chapter" data-chapter="chapter-10">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل دهم: JSON، شِما، آزمایش و مستندسازی</div>
    <div class="chapter-toggle toc-chapter-toggle">＋</div>
  </div>

  <ul class="toc-section-list">

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-10" data-section="section-10-1">
        <span>مبحث ۱: مقدمه – فصل پایانی مهارت‌ها</span>
        <small>اهمیت JSON و شِما</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-10" data-section="section-10-2">
        <span>مبحث ۲: JSON Repair (ترمیم JSON)</span>
        <small>اصلاح خودکار خروجی‌های خراب</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-10" data-section="section-10-3">
        <span>مبحث ۳: Schema Enforcement</span>
        <small>اجبار پیروی از ساختار مشخص</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-10" data-section="section-10-4">
        <span>مبحث ۴: Prompt Experimentation</span>
        <small>آزمایش و مقایسهٔ پرامپت‌ها</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-10" data-section="section-10-5">
        <span>مبحث ۵: Documentation Tools</span>
        <small>ساخت خودکار مستندات</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-10" data-section="section-10-6">
        <span>مبحث ۶: جمع‌بندی فصل دهم</span>
        <small>خلاصهٔ ابزارهای حرفه‌ای</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-10" data-section="section-10-7">
        <span>مبحث ۷: جمع‌بندی طلایی کل کتاب</span>
        <small>از کاربر تا پرامپت‌مهندس</small>
      </button>
    </li>

  </ul>
</li>

        
      </ul>
    </section>

    <!-- متن فصل‌ها و مبحث‌ها -->
    <section class="chapters">

      <!-- فصل اول -->
<article id="chapter-1" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل اول: پرامپت‌نویسی چیست و مدل چگونه کار می‌کند؟</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱ -->
    <section id="section-1-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – پرامپت و نقش آن</h3>

      <p>
        وقتی با یک مدل هوش مصنوعی مثل Gemini یا GPT حرف می‌زنی، چیزی که تایپ می‌کنی
        «پرامپت» نام دارد. پرامپت همان نقطهٔ شروع است؛ ورودی‌ای که مدل با آن تصمیم
        می‌گیرد چه متنی تولید کند.
      </p>

      <p>
        نوشتن پرامپت کار سختی نیست؛ اما نوشتن پرامپتی که خروجی دقیق، قابل اعتماد و
        درست بدهد، یک مهارت است.
      </p>

      <p>کیفیت جواب مدل به چند چیز بستگی دارد:</p>

      <ul>
        <li>خود متنِ پرامپت</li>
        <li>لحن و سبک نوشته</li>
        <li>ترتیب اطلاعات</li>
        <li>جزئیات و شفافیت</li>
        <li>مدل انتخاب‌شده</li>
        <li>تنظیمات مدل</li>
      </ul>

      <p>
        اگر پرامپت مبهم باشد، مدل نیز جواب مبهم می‌دهد. اگر پرامپت واضح باشد، مدل
        مسیر درست را پیدا می‌کند.
      </p>

      <p>
        پرامپت‌نویسی یک کار تکرارشونده است؛ تست می‌کنی، اصلاح می‌کنی، بهتر می‌کنی.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        مدل‌ها «معنی» را نمی‌فهمند؛ فقط پیش‌بینی می‌کنند. هر کلمهٔ تو یک چراغ است
        که مسیر پیش‌بینی را روشن می‌کند. اگر چراغ‌ها واضح باشند → مدل عالی پیش
        می‌رود؛ اگر تاریک یا نامرتب باشند → مدل به بیراهه می‌رود.
      </p>
    </section>

    <!-- مبحث ۲ -->
    <section id="section-1-2" class="section">
      <h3 class="section-title">مبحث ۲: مدل‌های زبانی چگونه پاسخ می‌سازند؟</h3>

      <p>
        مدل‌های زبانی مثل Gemini، GPT، Claude و… در اصل ماشین‌های پیش‌بینی متن
        هستند.
      </p>

      <p>کارشان را قدم‌به‌قدم این‌گونه انجام می‌دهند:</p>

      <ol>
        <li>پرامپت تو را می‌گیرند.</li>
        <li>بهترین کلمهٔ بعدی را حدس می‌زنند.</li>
        <li>آن کلمه را به متن اضافه می‌کنند.</li>
        <li>دوباره با توجه به کل متن، کلمهٔ بعدی را حدس می‌زنند.</li>
        <li>و همین‌طور تا پایان خروجی ادامه می‌دهند.</li>
      </ol>

      <p>
        به همین دلیل است که: پرامپت دقیق → خروجی دقیق، پرامپت مبهم → خروجی نامربوط،
        پرامپت طولانی و شلوغ → سردرگمی مدل.
      </p>

      <p>پرامپت خوب یعنی قرار دادن مدل در مسیر درست پیش‌بینی.</p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        این دقیقاً مثل راه رفتن در تاریکی است. تو با کلماتت چراغ‌قوه دست مدل
        می‌دهی. اگر نور کافی بدهی، به مقصد می‌رسد؛ اگر نور کم باشد، فقط حدس می‌زند
        و اشتباه می‌کند.
      </p>
    </section>

    <!-- مبحث ۳ -->
    <section id="section-1-3" class="section">
      <h3 class="section-title">مبحث ۳: پرامپت‌نویسی یعنی طراحی یک مسیر واضح</h3>

      <p>Prompt Engineering یعنی:</p>

      <ul>
        <li>مشخص کردن هدف</li>
        <li>ساده کردن درخواست</li>
        <li>جلوگیری از حدس‌های غیرضروری</li>
        <li>کم‌کردن ابهام</li>
        <li>اضافه کردن مثال در صورت نیاز</li>
      </ul>

      <p>هدف این است که مدل حدس‌های درست بزند، نه حدس‌های تصادفی.</p>
    </section>

    <!-- مبحث ۴ -->
    <section id="section-1-4" class="section">
      <h3 class="section-title">مبحث ۴: تنظیمات مدل و کنترل خروجی</h3>

      <p>
        این بخش یکی از مهم‌ترین قسمت‌هاست. علاوه بر خود پرامپت، تنظیمات مدل تعیین
        می‌کنند مدل چطور جواب بدهد.
      </p>

      <p>تنظیمات اصلی عبارتند از:</p>

      <ol>
        <li>تعداد توکن خروجی (Max Output Tokens)</li>
        <li>Temperature (دما)</li>
        <li>Top-K</li>
        <li>Top-P (Nucleus Sampling)</li>
      </ol>

      <h4>⭐ ۱) تعداد توکن خروجی</h4>
      <p>
        این گزینه فقط تعیین می‌کند مدل چقدر متن تولید کند. اگر مقدارش کم باشد →
        مدل وسط جمله متوقف می‌شود. اگر زیاد باشد → مدل فرصت کامل‌کردن پاسخ را دارد.
      </p>
      <p>
        کم بودن عدد به معنی خلاصه‌نویسی نیست؛ بلکه یعنی خروجی زورکی قطع شده است.
      </p>

      <h4>⭐ ۲) Temperature (دما)</h4>
      <p>
        Temperature تعیین می‌کند مدل چقدر «خلاق» یا «دقیق» باشد. دمای پایین →
        خروجی دقیق‌تر، منطقی‌تر و قابل‌پیش‌بینی‌تر. دمای بالا → خروجی خلاقانه‌تر،
        متنوع‌تر و غیرمنتظره‌تر.
      </p>
      <p>Temperature = 0 یعنی مدل همیشه «مطمئن‌ترین» کلمه را انتخاب می‌کند.</p>

      <h4>🔵 این تنظیمات کجا قابل تغییرند؟</h4>
      <p>
        در برنامه‌های چت معمولی مثل اپلیکیشن Gemini، سایت ChatGPT و ربات‌های آماده،
        این تنظیمات (Temperature، Top-P، Top-K) در دسترس کاربر عادی نیستند. سیستم
        خودش برای استفاده عمومی تنظیمات را انتخاب می‌کند.
      </p>

      <p>این تنظیمات فقط در سه حالت قابل تغییر هستند:</p>

      <h4>۱) Vertex AI Studio (گوگل کلود)</h4>
      <p>
        محیطی حرفه‌ای که کتاب هم بر اساس آن نوشته شده است. این‌جا می‌توانی
        Temperature، Top-K، Top-P و Max Tokens را دقیق تنظیم کنی.
      </p>

      <h4>۲) استفاده از API (برای ساخت ربات یا اپلیکیشن)</h4>
      <p>
        اگر مثل پروژهٔ Tavita یک ربات می‌سازی، تمام این تنظیمات را درون کد کنترل
        می‌کنی.
      </p>

<pre><code>model.generate(
    prompt="...",
    temperature=0.3,
    top_p=0.95,
    top_k=40,
    max_output_tokens=300
)
</code></pre>

      <h4>۳) ربات‌های سفارشی (مثل ربات ایتا / Tavita Bot)</h4>
      <p>
        در این حالت کاربر تنظیمات را نمی‌بیند، اما تو (توسعه‌دهنده) تعیین می‌کنی
        مدل چطور رفتار کند:
      </p>

      <ul>
        <li>Temperature = 0 → ربات دقیق و خشک</li>
        <li>Temperature ≈ 0.5 → ربات متعادل و روان</li>
        <li>Temperature ≈ 0.9 → ربات خلاق و آزاد</li>
      </ul>

      <h4>🔵 جمع‌بندی طاویتا درباره دسترسی به تنظیمات</h4>
      <ul>
        <li>در چت‌های معمولی → ❌ تنظیمات وجود ندارند.</li>
        <li>در Google Vertex AI Studio → ✔️ کامل در دسترس‌اند.</li>
        <li>در API و ربات شخصی → ✔️ قابل کنترل توسط برنامه‌نویس.</li>
      </ul>
      <p>این بخش را کتاب توضیح نداده بود؛ طاویتا آن را تکمیل کرد.</p>

      <h4>⭐ ۳) Top-K</h4>
      <p>
        Top-K انتخاب مدل را محدود می‌کند به K کلمهٔ محتمل‌تر. K پایین → خروجی دقیق
        و قابل‌پیش‌بینی. K بالا → خروجی متنوع‌تر.
      </p>
      <p>Top-K = 1 یعنی فقط بهترین حدس.</p>

      <h4>⭐ ۴) Top-P (Nucleus Sampling)</h4>
      <p>
        Top-P تعیین می‌کند مدل از بین کلماتی انتخاب کند که مجموع احتمالشان به P
        می‌رسد. P پایین → خروجی محدودتر؛ P بالا → خروجی آزادتر و خلاق‌تر.
      </p>

      <h4>🔵 توضیح طاویتا درباره Top-K و Top-P</h4>
      <p>
        Top-K مثل این است که بگویی: «فقط از بین ۵ انتخاب اولت یک‌دانه بردار.»  
        Top-P یعنی: «از بین انتخاب‌هایی که با هم مثلاً ۹۰٪ مطمئنی، یکی را انتخاب
        کن.»
      </p>
      <p>Top-K عدد محور است؛ Top-P احتمال‌محور است.</p>

      <h4>⭐ بهترین تنظیمات پیشنهادی کتاب</h4>
      <ul>
        <li>متن منظم + کمی خلاقیت: Temperature = 0.2 ، Top-P = 0.95 ، Top-K = 30</li>
        <li>متن بسیار خلاق و هنری: Temperature = 0.9 ، Top-P = 0.99 ، Top-K = 40</li>
        <li>کارهای علمی و قطعی: Temperature = 0</li>
      </ul>

      <h4>⭐ مشکل «لوپ تکرار»</h4>
      <p>
        اگر تنظیمات درست نباشند، مدل ممکن است کلمات را تکرار کند، گیر کند یا خروجی
        نامربوط تولید کند. این مشکل با تنظیم درست Temperature و Top-P تا حد زیادی
        برطرف می‌شود.
      </p>
    </section>

    <!-- مبحث ۵ -->
    <section id="section-1-5" class="section">
      <h3 class="section-title">مبحث ۵: جمع‌بندی فصل اول</h3>

      <ul>
        <li>مدل‌ها می‌نویسند چون پیش‌بینی می‌کنند.</li>
        <li>پرامپت خوب یعنی هدایت درست این پیش‌بینی.</li>
        <li>تنظیمات مدل، شدت خلاقیت، دقت و طول خروجی را کنترل می‌کند.</li>
        <li>برای کاربر معمولی این تنظیمات در دسترس نیست.</li>
        <li>فقط توسعه‌دهندگان می‌توانند آن‌ها را کنترل کنند.</li>
        <li>پرامپت‌نویسی یک مهارت هنری–فنی است.</li>
      </ul>
    </section>

  </div>
</article>

      <!-- فصل دوم -->
<article id="chapter-2" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل دوم: تکنیک‌های پرامپت‌نویسی (Prompting Techniques)</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱ -->
    <section id="section-2-1" class="section">
      <h3 class="section-title">مبحث ۱: Zero-shot Prompting</h3>

      <p>
        Zero-shot یعنی هیچ مثالی نمی‌دهی؛ فقط دستور را می‌نویسی. مدل براساس دانش
        قبلی‌اش تصمیم می‌گیرد.
      </p>

      <p>مثال:</p>
      <p><strong>«این متن را مثبت، منفی یا خنثی طبقه‌بندی کن.»</strong></p>

      <p>کجا استفاده می‌شود؟</p>
      <ul>
        <li>وقتی کار ساده است</li>
        <li>وقتی مدل دانش اولیه دارد</li>
        <li>وقتی نمی‌خواهی پرامپت طولانی شود</li>
      </ul>

      <p>
        اما همیشه دقیق نیست؛ چون مدل ممکن است سبک دلخواه تو را حدس نزند.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Zero-shot مثل این است که بگویی: «برو چای خوب درست کن» بدون اینکه بگویی
        چای پررنگ؟ کم‌رنگ؟ شیرین؟ اینجاست که خروجی ممکن است مطابق سلیقه‌ات نباشد.
      </p>
    </section>

    <!-- مبحث ۲ -->
    <section id="section-2-2" class="section">
      <h3 class="section-title">مبحث ۲: One-shot & Few-shot Prompting</h3>

      <p>
        One-shot یعنی یک مثال می‌دهی و مدل را در مسیر قرار می‌دهی. Few-shot یعنی
        چند مثال (معمولاً ۳ تا ۵) می‌دهی تا مدل الگو را کامل یاد بگیرد.
      </p>

      <p>مزیت‌ها:</p>
      <ul>
        <li>مدل دقیقاً می‌فهمد چه خروجی می‌خواهی</li>
        <li>لحن، سبک و ساختار از مثال‌ها یاد گرفته می‌شود</li>
        <li>احتمال خطا بسیار کم می‌شود</li>
      </ul>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Few-shot یعنی تو داری «قانون تولید خروجی» را به مدل یاد می‌دهی.  
        اگر مثال‌ها JSON باشند → مدل هم JSON می‌نویسد.  
        اگر مثال‌ها خیلی خلاصه باشند → خروجی هم خلاصه می‌شود.
      </p>
    </section>

    <!-- مبحث ۳ -->
    <section id="section-2-3" class="section">
      <h3 class="section-title">مبحث ۳: System Prompting (پرامپت سیستمی)</h3>

      <p>
        System prompt تعریف «وظیفه اصلی مدل» است. مثل اینکه بگویی:
      </p>

      <ul>
        <li>«تو یک مترجم حرفه‌ای هستی.»</li>
        <li>«فقط خروجی JSON بده.»</li>
        <li>«همیشه علمی و دقیق بنویس.»</li>
      </ul>

      <p>
        این دستور در ابتدای پرامپت می‌آید و رفتار کلی مدل را ثابت نگه می‌دارد.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        System prompt مثل این است که به مدل بگویی:  
        «این نقش توست، خارج نشو.»  
        اگر بگویی «تو یک متخصص امنیت سایبری هستی»، مدل همه‌چیز را از دید امنیتی
        می‌نویسد.
      </p>
    </section>

    <!-- مبحث ۴ -->
    <section id="section-2-4" class="section">
      <h3 class="section-title">مبحث ۴: Role Prompting (تعیین نقش)</h3>

      <p>
        در Role Prompting به مدل می‌گویی شبیه چه شخصیتی رفتار کند:
      </p>

      <ul>
        <li>«مثل یک نویسنده طنز صحبت کن.»</li>
        <li>«مثل یک پزشک عمومی توضیح بده.»</li>
        <li>«مثل یک مربی انگیزشی حرف بزن.»</li>
      </ul>

      <p>
        این روش برای کنترل لحن، احساس و سبک نوشتن مدل فوق‌العاده است.
      </p>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        Role Prompting مثل این است که یک «ماسک شخصیتی» روی مدل بگذاری.  
        حتی جواب‌های فنی هم می‌توانند شاعرانه، طنزآلود یا کودکانه شوند.
      </p>
    </section>

    <!-- مبحث ۵ -->
    <section id="section-2-5" class="section">
      <h3 class="section-title">مبحث ۵: Contextual Prompting (پرامپت با زمینه)</h3>

      <p>
        Context یعنی دادن اطلاعات پس‌زمینه‌ای تا مدل دقیق بفهمد در چه شرایطی هستی:
      </p>

      <ul>
        <li>«این متن مربوط به وبلاگ بازی‌های دهه ۸۰ است…»</li>
        <li>«در ادامهٔ گفت‌وگوی قبلی…»</li>
        <li>«اطلاعات اولیهٔ پروژه: …»</li>
      </ul>

      <p>با Context پاسخ‌ها دقیق‌تر و مرتبط‌تر می‌شوند.</p>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        Context مثل دادن “پس‌زمینه ذهنی” به مدل است.  
        اگر فقط بپرسی «سه موضوع مقاله بده» هر چیزی ممکن است بدهد.  
        اما اگر بگویی:  
        «در زمینهٔ بازی‌های کلاسیک دهه ۸۰، سه موضوع مقاله بده.»  
        مدل دقیقاً هدف‌مند می‌شود.
      </p>
    </section>

    <!-- مبحث ۶ -->
    <section id="section-2-6" class="section">
      <h3 class="section-title">مبحث ۶: جمع‌بندی فصل دوم</h3>

      <ul>
        <li>Zero-shot → سریع، ساده، اما نه‌چندان دقیق</li>
        <li>One-shot & Few-shot → بهترین روش برای خروجی باثبات</li>
        <li>System Prompt → تعیین چارچوب و رفتار کلی مدل</li>
        <li>Role Prompt → تعیین لحن، شخصیت و سبک پاسخ</li>
        <li>Contextual Prompt → دقیق‌ترین و هدفمندترین روش</li>
      </ul>

      <p>پرامپت خوب یعنی طراحی هوشمندانه مسیر ذهنی مدل.</p>
    </section>

  </div>
</article>

      <!-- فصل سوم -->
<article id="chapter-3" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل سوم: تکنیک‌های استدلال و تولید پاسخ هوشمند (Reasoning Prompts)</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱ -->
    <section id="section-3-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – چرا به استدلال نیاز داریم؟</h3>

      <p>
        فصل سوم دربارهٔ تکنیک‌هایی است که مدل را مجبور می‌کنند عمیق‌تر فکر کند.
        این تکنیک‌ها وقتی لازم‌اند که:
      </p>

      <ul>
        <li>کار پیچیده باشد</li>
        <li>نیاز به تحلیل داشته باشی</li>
        <li>چند مرحله پردازش لازم باشد</li>
        <li>مدل نباید جواب سطحی بدهد</li>
        <li>باید چند گزینه را مقایسه کند</li>
      </ul>

      <p>تکنیک‌های این فصل عبارت‌اند از:</p>
      <ol>
        <li>Step-back prompting</li>
        <li>Chain-of-Thought prompting</li>
        <li>Self-consistency reasoning</li>
        <li>Tree of Thought</li>
        <li>Deliberate prompting</li>
      </ol>
    </section>

    <!-- مبحث ۲ -->
    <section id="section-3-2" class="section">
      <h3 class="section-title">مبحث ۲: Step-back Prompting</h3>

      <p>
        در Step-back Prompting، قبل از اینکه مدل پاسخ بدهد، از او می‌خواهی یک قدم
        عقب‌تر برود و ابتدا مسئله را در سطحی کلی توضیح دهد.
      </p>

      <p>نمونهٔ ساده:</p>
      <blockquote>
        قبل از پاسخ، یک پاراگراف دربارهٔ این‌که مسئله چه نوع چالشی است بنویس، سپس
        جواب نهایی را بده.
      </blockquote>

      <p>این تکنیک باعث می‌شود مدل:</p>
      <ul>
        <li>موضوع را بهتر دسته‌بندی کند</li>
        <li>دید کلی پیدا کند</li>
        <li>از اشتباهات سریع جلوگیری کند</li>
        <li>از حالت «حدس‌زدن سریع» خارج شود</li>
      </ul>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Step-back مثل این است که قبل از حل مسئله بگویی:  
        «صبر کن… اول بگو این سؤال در چه دسته‌ای است؟ علمی، منطقی، احساسی یا تحلیلی؟»
      </p>
      <p>
        وقتی مدل این قدم را برمی‌دارد، کمتر اشتباهات بچگانه می‌کند و پاسخ‌ها
        انسانی‌تر و حرفه‌ای‌تر می‌شوند.
      </p>
    </section>

    <!-- مبحث ۳ -->
    <section id="section-3-3" class="section">
      <h3 class="section-title">مبحث ۳: Chain-of-Thought (زنجیرهٔ تفکر)</h3>

      <p>
        Chain-of-Thought یکی از معروف‌ترین تکنیک‌های دنیاست. یعنی از مدل می‌خواهی
        قبل از جواب نهایی، مرحله‌به‌مرحله فکرش را بنویسد.
      </p>

      <p>مثال:</p>
      <blockquote>
        مرحله‌به‌مرحله استدلال کن و سپس پاسخ نهایی را بده.
      </blockquote>

      <p>مزایا:</p>
      <ul>
        <li>مدل کمتر اشتباه می‌کند.</li>
        <li>جواب‌ها منطقی‌تر و قابل‌استنادتر می‌شوند.</li>
        <li>در ریاضی، تحلیل، پژوهش و تصمیم‌گیری بهتر عمل می‌کند.</li>
        <li>در پرسش‌های چندمرحله‌ای عالی است.</li>
      </ul>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Chain-of-Thought مدل را از حالت «حدس سریع» به حالت «تفکر مرحله‌دار» می‌برد.
        وقتی مدل مجبور شود مراحلش را بنویسد، نمی‌تواند الکی نتیجه‌گیری کند.
      </p>
      <p>
        برای کارهای تحقیقاتی، دانشجویی، تحلیل داده، پژوهش، حل مسئله، منطق و
        برنامه‌ریزی این تکنیک تقریباً ضروری است.
      </p>
    </section>

    <!-- مبحث ۴ -->
    <section id="section-3-4" class="section">
      <h3 class="section-title">مبحث ۴: Self-consistency reasoning</h3>

      <p>
        Self-consistency یعنی:
      </p>
      <ol>
        <li>چند Chain-of-Thought مختلف از مدل می‌گیری.</li>
        <li>مدل چند مسیر فکری متفاوت ایجاد می‌کند.</li>
        <li>در پایان از او می‌خواهی سازگارترین و منطقی‌ترین مسیر را انتخاب کند.</li>
      </ol>

      <p>
        این روش دقت را بالا می‌برد؛ چون مدل از بین چند راه‌حل، بهترین را انتخاب
        می‌کند.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Self-consistency مثل این است که بگویی:  
        «چند راه‌حل بده، بعد خودت منطقی‌ترین را انتخاب کن.»
      </p>
      <p>
        برای مسائل سخت، متون پژوهشی و تحلیل‌های چندلایه فوق‌العاده کاربردی است.
      </p>
    </section>

    <!-- مبحث ۵ -->
    <section id="section-3-5" class="section">
      <h3 class="section-title">مبحث ۵: Tree-of-Thought (درخت تفکر)</h3>

      <p>
        Tree-of-Thought یکی از پیشرفته‌ترین تکنیک‌هاست. در این روش، مدل به‌جای یک
        مسیر خطی، چند مسیر فکری را مثل شاخه‌های یک درخت می‌سازد.
      </p>

      <p>در Tree-of-Thought معمولاً:</p>
      <ul>
        <li>چند ایدهٔ مختلف تولید می‌شود.</li>
        <li>هر ایده کمی گسترش داده می‌شود.</li>
        <li>ایده‌ها با هم مقایسه می‌شوند.</li>
        <li>بهترین شاخهٔ فکری انتخاب می‌شود.</li>
        <li>در نهایت، جواب نهایی از روی آن شاخه ساخته می‌شود.</li>
      </ul>

      <p>
        این روش برای بازی‌های ذهنی، استراتژی، حل مسئله‌های باز و ایده‌پردازی
        عالی است.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Tree-of-Thought مثل این است که بگویی:  
        «چند مسیر فکری مختلف رسم کن، بعد بهترینشان را انتخاب کن.»
      </p>
      <p>
        در برنامه‌ریزی بلندمدت، تصمیم‌گیری پیچیده، تحلیل سناریو و طراحی استراتژی،
        این روش به مدل قدرت یک مشاور حرفه‌ای می‌دهد.
      </p>
    </section>

    <!-- مبحث ۶ -->
    <section id="section-3-6" class="section">
      <h3 class="section-title">مبحث ۶: Deliberate Prompting</h3>

      <p>
        Deliberate Prompting یعنی از مدل بخواهی «آهسته‌تر، عمیق‌تر و هدفمندتر»
        فکر کند.
      </p>

      <p>مثال:</p>
      <blockquote>
        قبل از پاسخ نهایی، با دقت فکر کن و در چند مرحله توضیح بده چگونه به نتیجه
        رسیدی.
      </blockquote>

      <p>این یک نسخهٔ ارتقایافته از Chain-of-Thought است و برای کارهای جدی و دقیق است.</p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Deliberate Prompting برای زمانی است که:
      </p>
      <ul>
        <li>نمی‌خواهی مدل جواب عجولانه بدهد.</li>
        <li>مسئله پیچیده است.</li>
        <li>دقت خیلی مهم است.</li>
        <li>خروجی باید توجیه منطقی داشته باشد.</li>
      </ul>

      <p>
        انگار به مدل می‌گویی: «عجله نکن. آرام و عمیق فکر کن. قدم‌به‌قدم جلو بیا،
        بعد نتیجه بده.» و واقعاً گاهی معجزه می‌کند.
      </p>
    </section>

    <!-- مبحث ۷ -->
    <section id="section-3-7" class="section">
      <h3 class="section-title">مبحث ۷: جمع‌بندی فصل سوم</h3>

      <ul>
        <li>Step-back → به مدل دید کلی بده و از اشتباهات ساده جلوگیری کن.</li>
        <li>Chain-of-Thought → مدل را مجبور کن مرحله‌به‌مرحله فکر کند.</li>
        <li>Self-consistency → چند مسیر فکری بگیر و بهترین را انتخاب کن.</li>
        <li>Tree-of-Thought → شاخه‌های مختلف فکر بساز و مقایسه کن.</li>
        <li>Deliberate Prompting → به مدل بگو آهسته، دقیق و مسئولانه فکر کند.</li>
      </ul>

      <p>
        این تکنیک‌ها، هوش مصنوعی را از یک «ماشین جواب سریع» به یک «همکار
        فکری و تحلیلی» تبدیل می‌کنند.
      </p>
    </section>

  </div>
</article>

<!-- فصل چهارم -->
<article id="chapter-4" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل چهارم: تکنیک‌های ساختاردهی خروجی (Structuring Responses)</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱: مقدمه -->
    <section id="section-4-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – چرا ساختاردهی خروجی مهم است؟</h3>

      <p>
        این فصل به تو یاد می‌دهد چطور کاری کنی که مدل:
      </p>
      <ul>
        <li>مرتب جواب بدهد،</li>
        <li>ساختارمند بنویسد،</li>
        <li>در یک قالب مشخص خروجی تولید کند،</li>
        <li>و از حدس و گمان بی‌مورد دوری کند.</li>
      </ul>

      <p>در این فصل با شش تکنیک مهم آشنا می‌شوی:</p>
      <ol>
        <li>Specification prompting (مشخصات دقیق خروجی)</li>
        <li>Format prompting (قالب‌بندی: JSON، Markdown، جدول و…)</li>
        <li>Pointwise prompting (پرسش‌گام‌به‌گام)</li>
        <li>Instruction hierarchy (سلسله‌مراتب دستورات)</li>
        <li>Rewriting prompts (بازنویسی بر اساس الگو)</li>
        <li>Multi-turn formatting (ساختاردهی در چند پیام)</li>
      </ol>
    </section>

    <!-- مبحث ۲: Specification -->
    <section id="section-4-2" class="section">
      <h3 class="section-title">مبحث ۲: Specification Prompting</h3>

      <p>
        Specification یعنی خیلی دقیق بنویسی که چه خروجی می‌خواهی. اگر فقط بگویی:
        «این متن را خلاصه کن»، خروجی می‌تواند یک جمله باشد یا یک پاراگراف طولانی.
      </p>

      <p>اما اگر بگویی:</p>
      <blockquote>
        این متن را در ۳ نکتهٔ اصلی، هر نکته حداکثر ۱۲ کلمه، با لحن رسمی خلاصه کن.
      </blockquote>

      <p>مدل دقیقاً مطابق همین مشخصات جواب می‌دهد.</p>

      <p><strong>Specification = کاهش ابهام + افزایش دقت.</strong></p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        مشخصات دقیق یعنی به مدل بگویی:
      </p>
      <ul>
        <li>مقدار خروجی چقدر باشد،</li>
        <li>چند بخش داشته باشد،</li>
        <li>لحن رسمی، دوستانه یا تخصصی باشد،</li>
        <li>محدودیت کلمه و جمله چیست،</li>
        <li>چه چیزهایی ممنوع است.</li>
      </ul>

      <p>هرچه تو دقیق‌تر باشی، مدل بهتر می‌درخشد.</p>
    </section>

    <!-- مبحث ۳: Format Prompting -->
    <section id="section-4-3" class="section">
      <h3 class="section-title">مبحث ۳: Format Prompting</h3>

      <p>
        Format Prompting یعنی خروجی را مجبور کنی در قالب مشخصی قرار بگیرد؛ مثلاً:
      </p>
      <ul>
        <li>JSON</li>
        <li>جدول</li>
        <li>لیست شماره‌دار</li>
        <li>Markdown</li>
        <li>HTML</li>
        <li>CSV</li>
        <li>پاراگراف با طول مشخص</li>
        <li>قالب پرسش و پاسخ</li>
      </ul>

      <p>مثال:</p>
      <blockquote>
        خروجی را فقط در قالب JSON استاندارد بده. هیچ توضیح اضافی ننویس.
      </blockquote>

      <p>یا:</p>
      <blockquote>
        نتیجه را در یک جدول ۳ ستونه بده: مفهوم | توضیح | مثال.
      </blockquote>

      <p>
        این تکنیک برای برنامه‌نویسی، ساخت ربات و استفاده از خروجی در سیستم‌های
        دیگر فوق‌العاده است.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        فرمت مشخص، مدل را از حاشیه رفتن و حرف‌های اضافی نجات می‌دهد. وقتی می‌گویی
        «فقط JSON»، مدل وسط آن شعر یا داستان نمی‌آورد و خروجی تمیز، قابل‌استفاده و
        استاندارد تحویل می‌دهد.
      </p>
      <p>
        اگر می‌خواهی خروجی را وارد برنامه، دیتابیس، UI یا هر سیستم دیگری کنی،
        فرمت‌دادن اجباری است.
      </p>
    </section>

    <!-- مبحث ۴: Pointwise -->
    <section id="section-4-4" class="section">
      <h3 class="section-title">مبحث ۴: Pointwise Prompting</h3>

      <p>
        Pointwise یعنی کار را نقطه‌به‌نقطه و بخش‌به‌بخش به مدل بدهی، نه یک‌باره.
      </p>

      <p>به‌جای اینکه بگویی:</p>
      <blockquote>
        یک مقالهٔ کامل بنویس.
      </blockquote>

      <p>این‌گونه می‌گویی:</p>
      <ol>
        <li>اول یک عنوان پیشنهادی بده.</li>
        <li>بعد یک مقدمه در دو پاراگراف بنویس.</li>
        <li>سپس بخش اصلی را در ۴ تیتر با توضیح کوتاه بنویس.</li>
        <li>در آخر یک جمع‌بندی یک پاراگرافی بده.</li>
      </ol>

      <p>
        این روش اجازه می‌دهد خروجی مرحله‌دار، تحت کنترل و با کیفیت بهتر تولید شود.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Pointwise یکی از بهترین روش‌ها برای تولید محتواست. وقتی وظیفه را به چند
        مرحله تقسیم می‌کنی، مدل کمتر اشتباه می‌کند و می‌توانی در هر مرحله اصلاح و
        هدایت کنی.
      </p>
      <p>
        در پروژه‌نویسی، مقاله‌نویسی، برنامه‌نویسی، سناریونویسی و ربات‌های آموزشی
        فوق‌العاده کاربرد دارد.
      </p>
    </section>

    <!-- مبحث ۵: Instruction Hierarchy -->
    <section id="section-4-5" class="section">
      <h3 class="section-title">مبحث ۵: Instruction Hierarchy (سلسله‌مراتب دستورات)</h3>

      <p>
        Instruction Hierarchy یعنی دستورات را از مهم‌ترین تا جزئی‌ترین مرتب کنی تا
        مدل بداند کدام قانون، اولویت دارد.
      </p>

      <p>مثال:</p>
      <ol>
        <li>قانون اصلی: فقط خروجی در قالب JSON بده.</li>
        <li>قانون دوم: هیچ متن اضافی ننویس.</li>
        <li>قانون سوم: پاسخ‌ها کوتاه باشند.</li>
        <li>قانون چهارم: لحن رسمی باشد.</li>
      </ol>

      <p>
        وقتی مدل بداند کدام دستور مهم‌تر است، در موقع تضاد، از قانون اصلی پیروی
        می‌کند.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        گاهی خودت ناخواسته در پرامپت تناقض ایجاد می‌کنی؛ مثلاً هم می‌گویی «کامل
        توضیح بده» و هم «کوتاه بنویس»! در این حالت، مدل نمی‌داند کدام را جدی‌تر
        بگیرد.
      </p>
      <p>
        با تعریف سلسله‌مراتب، به مدل می‌گویی: «این قانون از همه مهم‌تر است، بعد
        این، بعد این…» و به این ترتیب خروجی منظم و بدون تناقض می‌گیری.
      </p>
    </section>

    <!-- مبحث ۶: Rewriting -->
    <section id="section-4-6" class="section">
      <h3 class="section-title">مبحث ۶: Rewriting Prompts (بازنویسی بر اساس الگو)</h3>

      <p>
        در Rewriting از مدل می‌خواهی یک متن را بر اساس یک نمونهٔ مشخص بازنویسی
        کند.
      </p>

      <p>مثال:</p>
      <blockquote>
        این متن را دقیقاً با همین سبک نگارش نمونهٔ زیر بازنویسی کن:  
        [نمونهٔ متن]  
        حالا متن جدید را بازنویسی کن.
      </blockquote>

      <p>این روش برای این کارها عالی است:</p>
      <ul>
        <li>تقلید لحن،</li>
        <li>تقلید قالب نوشتاری،</li>
        <li>برندسازی،</li>
        <li>استانداردسازی محتوا،</li>
        <li>ایجاد یک امضای نوشتاری ثابت.</li>
      </ul>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        در این تکنیک، مدل از «الگوی رفتاری متن نمونه» یاد می‌گیرد؛ اگر نمونه رسمی
        باشد → خروجی رسمی می‌شود، اگر صمیمی باشد → خروجی صمیمی می‌شود، اگر طنز،
        شاعرانه یا آموزشی باشد → خروجی هم همان‌طور خواهد بود.
      </p>
      <p>
        برای ساخت لحن ثابت یک برند (مثلاً لحن خود طاویتا) این تکنیک فوق‌العاده
        است.
      </p>
    </section>

    <!-- مبحث ۷: Multi-turn Formatting -->
    <section id="section-4-7" class="section">
      <h3 class="section-title">مبحث ۷: Multi-turn Formatting</h3>

      <p>
        Multi-turn Formatting یعنی ساختاردهی خروجی در چند پیام پیاپی؛ به‌جای اینکه
        یک‌باره همه‌چیز را بگیری، مدل را مرحله‌به‌مرحله راهنمایی می‌کنی.
      </p>

      <p>مثلاً:</p>
      <ol>
        <li>اول بگو: «فقط قالب را بساز، هنوز محتوا تولید نکن.»</li>
        <li>بعد: «حالا بخش عنوان را پر کن.»</li>
        <li>بعد: «بخش مقدمه را پر کن.»</li>
        <li>سپس: «بخش نکات کلیدی را اضافه کن.»</li>
      </ol>

      <p>
        این روش باعث می‌شود خروجی تمیز، قابل‌مدیریت و باکیفیت شود و آشفتگی
        ایجاد نشود.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Multi-turn یعنی محتوا را مثل یک پروژهٔ واقعی، مرحله‌به‌مرحله پیش ببری.
        به‌جای یک پاسخ بزرگ و شاید شلخته، چند خروجی کوچک و استاندارد می‌گیری.
      </p>
      <p>
        این روش برای کارهای سنگین مثل ساخت کتاب، دورهٔ آموزشی، پروژه‌های بزرگ،
        طراحی UI و تولید اسناد کامل، بهترین گزینه است.
      </p>
    </section>

    <!-- مبحث ۸: جمع‌بندی -->
    <section id="section-4-8" class="section">
      <h3 class="section-title">مبحث ۸: جمع‌بندی فصل چهارم</h3>

      <ul>
        <li><strong>Specification:</strong> دقیق بگو چه خروجی می‌خواهی.</li>
        <li><strong>Format prompting:</strong> خروجی را مجبور کن در قالب خاصی باشد.</li>
        <li><strong>Pointwise:</strong> وظیفه را مرحله‌دار کن.</li>
        <li><strong>Instruction hierarchy:</strong> اهمیت دستورات را مشخص کن.</li>
        <li><strong>Rewriting:</strong> متن جدید را مطابق یک نمونه بازنویسی کن.</li>
        <li><strong>Multi-turn:</strong> خروجی سنگین را در چند مرحله بساز.</li>
      </ul>

      <p>
        با این تکنیک‌ها، هوش مصنوعی فقط «جواب‌دهنده» نیست؛ تبدیل می‌شود به ابزاری
        که خروجی تمیز، حرفه‌ای و قابل‌استفاده در دنیای واقعی تولید می‌کند.
      </p>
    </section>

  </div>
</article>


<!-- فصل پنجم -->
<article id="chapter-5" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل پنجم: خطاها، محدودیت‌ها، کنترل کیفیت و بهبود دقت مدل‌ها</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱ -->
    <section id="section-5-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – چرا کنترل کیفیت ضروری است؟</h3>

      <p>
        این فصل یاد می‌دهد چگونه کاری کنیم که مدل کمتر اشتباه کند، کمتر اطلاعات ساختگی
        بسازد، از موضوع خارج نشود و خروجی قابل اعتماد تولید کند. این فصل برای پژوهش،
        محصول‌سازی، ربات‌سازی و تحلیل داده حیاتی است.
      </p>

      <ul>
        <li>شناخت محدودیت‌ها</li>
        <li>شناخت هذیان یا Hallucination</li>
        <li>کاهش خطا</li>
        <li>مدیریت محتوای حساس (Safety)</li>
        <li>راستی‌آزمایی خروجی</li>
        <li>اتصال به داده واقعی (Grounding)</li>
        <li>رعایت Guardrails</li>
        <li>Self-checking توسط خود مدل</li>
      </ul>
    </section>

    <!-- مبحث ۲ -->
    <section id="section-5-2" class="section">
      <h3 class="section-title">مبحث ۲: محدودیت‌های مدل</h3>

      <p>مدل‌های زبانی محدودیت‌هایی دارند:</p>

      <ul>
        <li>دانش‌شان محدود به دادهٔ آموزشی است.</li>
        <li>حقیقت را «نمی‌دانند»؛ فقط پیش‌بینی می‌کنند.</li>
        <li>ممکن است اطلاعات غلط تولید کنند.</li>
        <li>ممکن است با اعتمادبه‌نفس غلط صحبت کنند.</li>
        <li>ممکن است چیز غلط را منطقی جلوه دهند.</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        مدل «دانشمند» نیست؛ «حدس‌زن ماهر» است. لحنش فقط وانمود می‌کند که مطمئن است.
      </p>
    </section>

    <!-- مبحث ۳ -->
    <section id="section-5-3" class="section">
      <h3 class="section-title">مبحث ۳: Hallucination – اطلاعات ساختگی</h3>

      <p>Hallucination یعنی:</p>

      <ul>
        <li>اطلاعات ساختگی اما طبیعی‌به‌نظر تولید کند.</li>
        <li>ارجاع ساختگی بسازد.</li>
        <li>آمار جعلی بدهد.</li>
        <li>تاریخ یا واقعه‌ای بسازد.</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        وقتی مدل جواب دقیق ندارد، به‌جای «نمی‌دانم» چیزی می‌سازد که منطقی به‌نظر برسد.
      </p>
    </section>

    <!-- مبحث ۴ -->
    <section id="section-5-4" class="section">
      <h3 class="section-title">مبحث ۴: تکنیک‌های کاهش خطا</h3>

      <ul>
        <li><strong>۱) Chain-of-Thought:</strong> درخواست استدلال مرحله‌به‌مرحله.</li>
        <li><strong>۲) محدودیت‌های دقیق:</strong> مثل «اگر مطمئن نیستی بگو نمی‌دانم».</li>
        <li><strong>۳) اجبار به منبع (Force citation):</strong> مدل را مجبور کن سند بدهد.</li>
        <li><strong>۴) Grounding:</strong> اتصال به دیتابیس یا API.</li>
        <li><strong>۵) Temperature پایین:</strong> حدس کمتر → خطای کمتر.</li>
        <li><strong>۶) Self-check:</strong> درخواست بازبینی و اصلاح.</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        با جمله «جوابت را بررسی کن»، مدل وارد حالت ارزیابی می‌شود و خودش اشتباهات را اصلاح می‌کند.
      </p>
    </section>

    <!-- مبحث ۵ -->
    <section id="section-5-5" class="section">
      <h3 class="section-title">مبحث ۵: Safety و محتوای ممنوع</h3>

      <p>مدل‌ها برای جلوگیری از سوءاستفاده محدودیت دارند:</p>

      <ul>
        <li>محتوای خطرناک</li>
        <li>نفرت‌پراکنی</li>
        <li>افشای اطلاعات خصوصی</li>
        <li>خشونت</li>
        <li>سوگیری‌های حساس</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        در ربات‌سازی، Safety یعنی تعیین اینکه مدل چه چیزهایی را «نباید» تولید کند.
      </p>
    </section>

    <!-- مبحث ۶ -->
    <section id="section-5-6" class="section">
      <h3 class="section-title">مبحث ۶: Verification – راستی‌آزمایی خروجی</h3>

      <p>
        در Verification از مدل می‌خواهی:
      </p>

      <ul>
        <li>خروجی خودش را ارزیابی کند.</li>
        <li>سه دلیل برای احتمال اشتباه بیاورد.</li>
        <li>نسخهٔ اصلاح‌شده ارائه دهد.</li>
      </ul>

      <blockquote>
        «این پاسخ را بررسی کن. اگر غلط است، نسخهٔ درست را بده.»
      </blockquote>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        مدل در حالت Verification دقیق‌تر، محتاط‌تر و تحلیل‌گرتر رفتار می‌کند.
      </p>
    </section>

    <!-- مبحث ۷ -->
    <section id="section-5-7" class="section">
      <h3 class="section-title">مبحث ۷: Grounding – اتصال به واقعیت</h3>

      <p>
        Grounding یعنی مدل را به اطلاعات واقعی وصل کنی:
      </p>

      <ul>
        <li>دیتابیس</li>
        <li>API</li>
        <li>فایل‌ها</li>
        <li>اسناد</li>
        <li>دادهٔ علمی</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        در ربات‌های حرفه‌ای مثل Tavita Bot، Grounding باعث می‌شود مدل به جای حدس، واقعیت بگوید.
      </p>
    </section>

    <!-- مبحث ۸ -->
    <section id="section-5-8" class="section">
      <h3 class="section-title">مبحث ۸: Guardrails – ریل‌های محافظتی</h3>

      <p>
        Guardrails یعنی:
      </p>

      <ul>
        <li>چه موضوعی ممنوع است؟</li>
        <li>در شرایط خطر چه پاسخی بدهد؟</li>
        <li>چه کلمه‌هایی فیلتر شود؟</li>
        <li>درخواستی خلاف قوانین → رد شود.</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        در ربات‌سازی Guardrails = امنیت محتوایی. ضروری و حیاتی است.
      </p>
    </section>

    <!-- مبحث ۹ -->
    <section id="section-5-9" class="section">
      <h3 class="section-title">مبحث ۹: Self-checking – بررسی و اصلاح توسط مدل</h3>

      <p>
        Self-checking یعنی از مدل بخواهی:
      </p>

      <blockquote>
        «خروجی بالا را بررسی کن. اگر اشتباهی هست، اصلاح کن.»
      </blockquote>

      <p>
        در این حالت مدل:
      </p>

      <ul>
        <li>خطاها را تشخیص می‌دهد،</li>
        <li>نسخهٔ دقیق‌تر ارائه می‌دهد،</li>
        <li>کیفیت خروجی را بالا می‌برد.</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        این تکنیک برای پژوهش و داده‌های حساس بسیار مهم است.
      </p>
    </section>

    <!-- مبحث ۱۰ -->
    <section id="section-5-10" class="section">
      <h3 class="section-title">مبحث ۱۰: جمع‌بندی فصل پنجم</h3>

      <ul>
        <li>مدل‌ها محدودند → حقیقت را «نمی‌دانند».</li>
        <li>Hallucination رایج است → باید مدیریت شود.</li>
        <li>کاهش خطا با CoT، محدودیت، Self-check و دمای پایین.</li>
        <li>Safety برای جلوگیری از سوءاستفاده ضروری است.</li>
        <li>Verification دقت خروجی را چند برابر می‌کند.</li>
        <li>Grounding اتصال به واقعیت است.</li>
        <li>Guardrails برای ربات‌سازی حیاتی‌اند.</li>
        <li>Self-checking بهترین ابزار پالایش خروجی است.</li>
      </ul>

      <p>
        این فصل مدل تو را از یک «ماشین پیش‌بینی» تبدیل می‌کند به «ابزار حرفه‌ای و قابل اعتماد».
      </p>
    </section>

  </div>
</article>

<!-- فصل ششم -->
<article id="chapter-6" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل ششم: ReAct، مهندسی پرامپت خودکار و تفکر + اقدام</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱ -->
    <section id="section-6-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – ورود به عصر Agentها</h3>

      <p>
        در این فصل وارد مرحله‌ای می‌شویم که مدل فقط «فکر» نمی‌کند؛
        بلکه فکر می‌کند + اقدام می‌کند + به نتیجه می‌رسد.
      </p>

      <p>
        این رفتار پایهٔ بسیاری از عامل‌های هوشمند (AI Agents) است که در دنیای واقعی
        برای تصمیم‌گیری، تحلیل، برنامه‌ریزی و انجام کارهای پیچیده استفاده می‌شوند.
      </p>

      <p>این فصل روی دو تکنیک بزرگ تمرکز دارد:</p>

      <ul>
        <li><strong>ReAct (Reason + Act)</strong></li>
        <li><strong>Automatic Prompt Engineering (APE)</strong></li>
      </ul>

      <p>که زیربنای ربات‌های حرفه‌ای، سیستم‌های خودکار و ابزارهای نسل آینده‌اند.</p>
    </section>

    <!-- مبحث ۲ -->
    <section id="section-6-2" class="section">
      <h3 class="section-title">مبحث ۲: ReAct — Reason + Act</h3>

      <p>ReAct یعنی مدل:</p>

      <ul>
        <li>فکر کند (Reason)</li>
        <li>اقدام کند (Act)</li>
        <li>نتیجهٔ عمل را ببیند (Observation)</li>
        <li>دوباره فکر کند و پاسخ بدهد</li>
      </ul>

      <p>مدل وارد چرخهٔ زیر می‌شود:</p>

      <pre>
Reason → Act → Observation → Reason → Answer
      </pre>

      <p>
        این رفتار در ربات‌های پیچیده، تحلیل داده، دستیارهای حرفه‌ای و عامل‌های هوشمند کاربرد گسترده دارد.
      </p>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        ReAct یعنی به مدل اجازه دهی بگوید:
        «صبر کن… باید کاری انجام دهم تا اطلاعات بیشتری پیدا کنم.»
      </p>

      <p>
        این کار خروجی مدل را دقیق‌تر، قابل‌اعتمادتر و هدفمندتر می‌کند.
      </p>
    </section>

    <!-- مبحث ۳ -->
    <section id="section-6-3" class="section">
      <h3 class="section-title">مبحث ۳: ساختار کلی ReAct</h3>

      <p>فرمت عمومی ReAct این‌گونه است:</p>

      <pre>
Thought: ...
Action: ...
Observation: ...
Thought: ...
Answer: ...
      </pre>

      <p>
        این ساختار به مدل کمک می‌کند با منطق سازمان‌یافته فکر کند، کمتر اشتباه کند
        و از منابع خارجی یا ابزارهای موجود استفاده کند.
      </p>
    </section>

    <!-- مبحث ۴ -->
    <section id="section-6-4" class="section">
      <h3 class="section-title">مبحث ۴: چه زمانی از ReAct استفاده کنیم؟</h3>

      <p>ReAct زمانی ضروری است که:</p>

      <ul>
        <li>پاسخ ساده کافی نیست،</li>
        <li>مدل باید تحلیل عمیق انجام دهد،</li>
        <li>چند مرحله نیاز به بررسی داده باشد،</li>
        <li>مسئله پژوهشی یا سیستمی باشد،</li>
        <li>نیاز به جستجو یا راستی‌آزمایی باشد.</li>
      </ul>

      <p>کاربردها:</p>

      <ul>
        <li>عامل‌های هوشمند</li>
        <li>جمع‌آوری داده</li>
        <li>تحلیل پژوهشی</li>
        <li>بررسی خطا</li>
        <li>برنامه‌ریزی و تصمیم‌گیری</li>
      </ul>
    </section>

    <!-- مبحث ۵ -->
    <section id="section-6-5" class="section">
      <h3 class="section-title">مبحث ۵: مزایای ReAct</h3>

      <ul>
        <li>کاهش خطا</li>
        <li>افزایش دقت</li>
        <li>کاهش هذیان (Hallucination)</li>
        <li>ایجاد تفکر سازمان‌یافته در مدل</li>
        <li>پایه‌گذاری رفتار عامل‌های حرفه‌ای</li>
        <li>انعطاف‌پذیری بالا در پاسخ‌دهی</li>
      </ul>
    </section>

    <!-- مبحث ۶ -->
    <section id="section-6-6" class="section">
      <h3 class="section-title">مبحث ۶: Automatic Prompt Engineering (APE)</h3>

      <p>
        APE یعنی مدل خودش مهندس پرامپت شود!
      </p>

      <p>
        به‌جای اینکه تو پرامپت‌های متعدد تست کنی، مدل خودش:
      </p>

      <ol>
        <li>هدف را تحلیل می‌کند،</li>
        <li>چند پرامپت مختلف می‌سازد،</li>
        <li>آن‌ها را آزمایش می‌کند،</li>
        <li>بهترین پرامپت را انتخاب می‌کند.</li>
      </ol>

      <p>
        این تکنیک در Google Vertex AI Studio و پروژه‌های پیشرفته به‌کار می‌رود.
      </p>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        این کار شبیه این است که بگویی:
        «تو بهتر از من می‌فهمی چطور با خودت حرف بزنی—پس پرامپت مناسب را خودت بساز.»
      </p>
    </section>

    <!-- مبحث ۷ -->
    <section id="section-6-7" class="section">
      <h3 class="section-title">مبحث ۷: کاربردهای APE</h3>

      <ul>
        <li>ساخت ربات‌های بسیار هوشمند</li>
        <li>پروژه‌های داده‌ای</li>
        <li>سیستم‌های خودکار</li>
        <li>تولید محتوای دقیق</li>
        <li>بهینه‌سازی رفتار مدل برای یک وظیفهٔ خاص</li>
      </ul>

      <p>
        APE باعث صرفه‌جویی عظیم در زمان و افزایش دقت می‌شود.
      </p>
    </section>

    <!-- مبحث ۸ -->
    <section id="section-6-8" class="section">
      <h3 class="section-title">مبحث ۸: جمع‌بندی فصل ششم</h3>

      <ul>
        <li><strong>ReAct:</strong> ترکیب تفکر + اقدام → مناسب برای کارهای پیچیده.</li>
        <li><strong>APE:</strong> مدل خودش بهترین پرامپت را می‌سازد.</li>
        <li>این فصل مقدمهٔ ورود به «Code Prompting» در فصل هفتم است.</li>
      </ul>

      <p>
        از این فصل به بعد وارد دنیای مدل‌هایی می‌شویم که فکر می‌کنند، عمل می‌کنند،
        از ابزارها استفاده می‌کنند و حتی کدنویسی را خودکار انجام می‌دهند.
      </p>
    </section>

  </div>
</article>

<!-- فصل هفتم -->
<article id="chapter-7" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل هفتم: مهندسی پرامپت برای کدنویسی (Code Prompting)</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱ -->
    <section id="section-7-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – چرا Code Prompting مهم است؟</h3>

      <p>
        مدل‌های هوش مصنوعی فقط «تولید متن» نیستند؛ در واقع از قوی‌ترین ماشین‌های
        تحلیل و بازنویسی کد در دنیا هستند. با پرامپت درست، مدل می‌تواند:
      </p>

      <ul>
        <li>کد تولید کند،</li>
        <li>کد را توضیح دهد،</li>
        <li>کد را بین زبان‌ها ترجمه کند،</li>
        <li>باگ‌ها را پیدا و اصلاح کند،</li>
        <li>کد را تمیز و بهینه کند (Refactor)،</li>
        <li>تست بنویسد،</li>
        <li>معماری و ساختار پروژه پیشنهاد بدهد.</li>
      </ul>

      <p>
        این فصل به تو یاد می‌دهد چطور این قدرت را با پرامپت‌نویسی حرفه‌ای مهار کنی
        و مدل را به یک دستیار واقعی برنامه‌نویسی تبدیل کنی.
      </p>
    </section>

    <!-- مبحث ۲ -->
    <section id="section-7-2" class="section">
      <h3 class="section-title">مبحث ۲: Comment-to-Code Prompting</h3>

      <p>
        Comment-to-Code یکی از ساده‌ترین و قدرتمندترین روش‌هاست:  
        اول «توضیح متنی» می‌دهی، بعد از مدل «کد» می‌خواهی.
      </p>

      <p>مثال:</p>
      <blockquote>
        یک تابع می‌خواهم که ورودی‌اش عدد باشد و زوج یا فرد بودن را برگرداند.
        لطفاً فقط کد بده، بدون توضیح.
      </blockquote>

      <blockquote>
        این ویژگی را می‌خواهم:<br>
        - گرفتن نام کاربر<br>
        - ذخیره در دیتابیس<br>
        - برگرداندن مقدار تأیید<br>
        لطفاً کد Node.js بنویس.
      </blockquote>

      <p>
        تو فقط رفتار مورد نظر را توضیح می‌دهی؛ مدل با توجه به دانشش بهترین پیاده‌سازی را
        پیشنهاد می‌کند.
      </p>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        Comment-to-code یعنی:
        <strong>«تو می‌گویی چه کار باید انجام شود؛ مدل می‌نویسد چطور انجام شود.»</strong>  
        بهترین روش برای شروع پروژه، گرفتن اسکلت اولیه، یا تست سریع ایده‌هاست.
      </p>
    </section>

    <!-- مبحث ۳ -->
    <section id="section-7-3" class="section">
      <h3 class="section-title">مبحث ۳: Code Explanation Prompt</h3>

      <p>
        در این تکنیک از مدل می‌خواهی کد را به زبان ساده و قابل‌فهم توضیح دهد.  
        مثلاً:
      </p>

      <blockquote>
        کد زیر را خط‌به‌خط توضیح بده، خیلی ساده و برای یک فرد تازه‌کار.
      </blockquote>

      <blockquote>
        هدف این فایل چیست؟ در سه نکتهٔ کوتاه بگو.
      </blockquote>

      <p>کاربردها:</p>
      <ul>
        <li>فهمیدن کد دیگران،</li>
        <li>مطالعهٔ سریع پروژه‌های بزرگ،</li>
        <li>آموزش و یادگیری،</li>
        <li>تولید مستندات برای تیم یا مشتری.</li>
      </ul>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        وقتی مدل برایت کد را توضیح می‌دهد، مثل یک مدرس خصوصی در کنارت می‌نشیند.  
        این یکی از سریع‌ترین و عمیق‌ترین روش‌ها برای یادگیری واقعی برنامه‌نویسی است.
      </p>
    </section>

    <!-- مبحث ۴ -->
    <section id="section-7-4" class="section">
      <h3 class="section-title">مبحث ۴: Translating Code Between Languages</h3>

      <p>
        یکی از قوی‌ترین کاربردها، ترجمهٔ کد بین زبان‌های مختلف است؛ مثل:
      </p>

      <ul>
        <li>Python → JavaScript</li>
        <li>PHP → Node.js</li>
        <li>Java → Kotlin</li>
        <li>C++ → Rust</li>
        <li>و حتی تبدیل منطق بین موتورهای بازی (مثلاً Unreal ↔ Unity)</li>
      </ul>

      <p>نمونهٔ پرامپت:</p>
      <blockquote>
        این تابع پایتون را به جاوااسکریپت مدرن ES6 ترجمه کن. ساختار را حفظ کن،  
        اما سینتکس را استاندارد و خوانا کن.
      </blockquote>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        این تکنیک برای مهاجرت پروژه‌ها، ساخت نسخهٔ جدید از یک اپلیکیشن، یا هماهنگ‌کردن
        backend و frontend فوق‌العاده است.
      </p>
    </section>

    <!-- مبحث ۵ -->
    <section id="section-7-5" class="section">
      <h3 class="section-title">مبحث ۵: Debugging Prompting (دیباگ خودکار)</h3>

      <p>
        در دیباگ خودکار، از مدل می‌خواهی:
      </p>

      <ul>
        <li>کد را بخواند،</li>
        <li>خطاها را پیدا کند،</li>
        <li>دلیل خطا را توضیح بدهد،</li>
        <li>نسخهٔ اصلاح‌شده را بنویسد.</li>
      </ul>

      <p>نمونهٔ پرامپت:</p>
      <blockquote>
        کد زیر اجرا نمی‌شود. خطا را پیدا کن، دلیلش را توضیح بده و نسخهٔ کامل اصلاح‌شده را بده.
      </blockquote>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        مدل در دیباگ فوق‌العاده قدرتمند است، چون:
      </p>
      <ul>
        <li>یک‌جا کل فایل را می‌بیند،</li>
        <li>منطق کلی را تحلیل می‌کند،</li>
        <li>با الگوهای رایج خطا در زبان‌های مختلف آشناست.</li>
      </ul>
      <p>انگار یک Senior Developer حرفه‌ای کنار دستت نشسته باشد.</p>
    </section>

    <!-- مبحث ۶ -->
    <section id="section-7-6" class="section">
      <h3 class="section-title">مبحث ۶: Refactoring (بازنویسی و پاک‌سازی کد)</h3>

      <p>
        Refactor یعنی کد را به نسخه‌ای:
      </p>

      <ul>
        <li>تمیزتر،</li>
        <li>خواناتر،</li>
        <li>کوتاه‌تر،</li>
        <li>سریع‌تر،</li>
        <li>و قابل‌نگهداری‌تر تبدیل کنی.</li>
      </ul>

      <p>مثال پرامپت:</p>
      <blockquote>
        این کد را طوری بازنویسی کن که:<br>
        - خوانایی بیشتر شود<br>
        - وابستگی‌های غیرضروری حذف شود<br>
        - سرعت بهتر شود<br>
        - توابع کوتاه و واضح باشند<br>
        لطفاً فقط نسخهٔ جدید کد را بده.
      </blockquote>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        این تکنیک برای پروژه‌هایی مثل ربات ایتا، بازی‌ها یا سرویس‌های تحت وب فوق‌العاده
        است؛ به‌جای بازنویسی دستی، مدل به تو نسخه‌ای حرفه‌ای و تمیز می‌دهد.
      </p>
    </section>

    <!-- مبحث ۷ -->
    <section id="section-7-7" class="section">
      <h3 class="section-title">مبحث ۷: Writing Tests و Documentation from Code</h3>

      <p>
        مدل می‌تواند برای کدها:
      </p>

      <ul>
        <li>تست واحد (Unit test)،</li>
        <li>تست یکپارچه (Integration test)،</li>
        <li>تست برای ورودی‌های اشتباه،</li>
        <li>و تست برای حالت‌های لبه (Edge cases)</li>
        بنویسد.
      </ul>

      <p>نمونهٔ پرامپت تست:</p>
      <blockquote>
        برای تابع زیر تست‌های Jest بنویس که ورودی‌های اشتباه را هم پوشش دهد.
      </blockquote>

      <p>و برای مستندسازی:</p>
      <blockquote>
        برای این کلاس مستندات کامل Markdown تولید کن، شامل: توضیح کلی، پارامترها،
        مثال، خروجی و خطاهای احتمالی.
      </blockquote>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        این روش برای ساخت README، Wiki پروژه، مستندات API و تحویل پروژه به تیم یا
        مشتری فوق‌العاده است. تو فقط کد را می‌دهی؛ مدل خودش مستندات حرفه‌ای تولید
        می‌کند.
      </p>
    </section>

    <!-- مبحث ۸ -->
    <section id="section-7-8" class="section">
      <h3 class="section-title">مبحث ۸: Architecture & File Planning</h3>

      <p>
        در این تکنیک، از مدل می‌خواهی ساختار کلی پروژه را طراحی کند؛ شامل:
      </p>

      <ul>
        <li>پوشه‌ها و فایل‌ها،</li>
        <li>ماژول‌ها و لایه‌ها،</li>
        <li>مسیرهای API،</li>
        <li>دیتابیس و جداول،</li>
        <li>کامپوننت‌های Frontend (مثلاً React / Next.js).</li>
      </ul>

      <p>نمونهٔ پرامپت:</p>
      <blockquote>
        برای یک وب‌سایت فروشگاهی با Next.js و MongoDB،  
        ساختار کامل فایل‌ها و پوشه‌ها را پیشنهاد بده،  
        و برای هر پوشه توضیح کوتاهی بنویس.
      </blockquote>

      <p>
        نتیجه معمولاً یک معماری حرفه‌ای است که می‌توانی مستقیماً در پروژه‌ات استفاده
        کنی.
      </p>
    </section>

    <!-- مبحث ۹ -->
    <section id="section-7-9" class="section">
      <h3 class="section-title">مبحث ۹: جمع‌بندی فصل هفتم</h3>

      <ul>
        <li><strong>Comment → Code:</strong> از توضیح متنی، کد بساز.</li>
        <li><strong>Code → Explanation:</strong> کد را به زبان ساده و آموزشی توضیح بده.</li>
        <li><strong>ترجمهٔ بین زبان‌ها:</strong> Python، JS، Java، C++ و…</li>
        <li><strong>Debugging:</strong> خطا → تحلیل → نسخهٔ اصلاح‌شده.</li>
        <li><strong>Refactor:</strong> کد سنگین → کد تمیز، کوتاه و خوانا.</li>
        <li><strong>Tests & Docs:</strong> تولید تست و مستندات خودکار.</li>
        <li><strong>Architecture:</strong> پیشنهاد ساختار حرفه‌ای برای کل پروژه.</li>
      </ul>

      <p>
        این فصل نشان می‌دهد که مدل فقط «نویسندهٔ متن» نیست؛  
        یک همکار جدی در برنامه‌نویسی، طراحی سیستم و توسعهٔ محصول است.
      </p>
    </section>

  </div>
</article>

<!-- فصل هشتم -->
<article id="chapter-8" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل هشتم – پرامپت‌های چندرسانه‌ای (Multimodal Prompting)</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱: مقدمه -->
    <section id="section-8-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – پرامپت‌های چندرسانه‌ای چیست؟</h3>

      <p>
        🌟 فصل هشتم – پرامپت‌های چندرسانه‌ای (Multimodal Prompting)
      </p>

      <p>
        (نسخه‌ی ساده‌سازی‌شده + توضیحات اختصاصی طاویتا)
      </p>

      <p>
        این فصل بر اساس صفحات 54–60 کتاب اصلی نوشته شده است و کامل‌ترین نگاه را به این می‌دهد
        که چطور مدل با عکس، ویدیو، صدا، نمودار، PDF، طراحی و… کار می‌کند.
      </p>

      <p>این فصل برای کارهایی مثل:</p>
      <ul>
        <li>تحلیل تصویر</li>
        <li>توضیح عکس</li>
        <li>استخراج اطلاعات از PDF</li>
        <li>طراحی UI</li>
        <li>ایده‌پردازی بصری</li>
        <li>پردازش صوت</li>
        <li>ساخت مدل‌های چندعاملی</li>
        <li>ربات‌های تشخیص تصویر</li>
        <li>پردازش ویدیو</li>
      </ul>

      <p>فوق‌العاده مهم است.</p>
    </section>

    <!-- مبحث ۲: چندرسانه‌ای یعنی چه؟ -->
    <section id="section-8-2" class="section">
      <h3 class="section-title">مبحث ۲: چندرسانه‌ای یعنی چه؟</h3>

      <p>
        🌟 چندرسانه‌ای یعنی چه؟
      </p>

      <p>
        تا اینجا مدل‌ها فقط با متن کار می‌کردند. اما مدل‌های جدید (مثل Gemini،
        GPT-4o، Claude 3.5) می‌توانند:
      </p>

      <ul>
        <li>ببینند (تصویر)</li>
        <li>بشنوند (صوت)</li>
        <li>تحلیل کنند (ویدئو)</li>
        <li>بخوانند (PDF، اسناد)</li>
        <li>طراحی‌ها را بفهمند</li>
      </ul>

      <p>این یعنی مدل مثل یک «موجود چندحسی» عمل می‌کند.</p>
    </section>

    <!-- مبحث ۳: Image-to-Text -->
    <section id="section-8-3" class="section">
      <h3 class="section-title">مبحث ۳: Image-to-Text Prompting</h3>

      <p>⭐ ۱) Image-to-Text Prompting</p>
      <p>(صفحه 54–56)</p>

      <p>این بخش توضیح می‌دهد چطور از مدل بخواهی:</p>
      <ul>
        <li>عکس را توضیح دهد</li>
        <li>جزئیات را پیدا کند</li>
        <li>اشیا را تشخیص دهد</li>
        <li>ویژگی‌ها را توصیف کند</li>
        <li>مشکلات طراحی را مشخص کند</li>
        <li>متن موجود در عکس را استخراج کند (OCR)</li>
      </ul>

      <p>مثال پرامپت قوی:</p>

      <blockquote>
        «عکس زیر را تحلیل کن.
        <br>اشیاء را نام ببر
        <br>رابطه بین آن‌ها را توضیح بده
        <br>اگر عناصر نامعمول یا خطرناک وجود دارد، مشخص کن
        <br>در نهایت یک خلاصهٔ یک‌پاراگرافی بده.»
      </blockquote>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        مودل‌های جدید فقط «توضیح» نمی‌دهند، حتی می‌توانند:
      </p>
      <ul>
        <li>طراحی UI را به کد تبدیل کنند</li>
        <li>رنگ‌ها و سبک‌ها را تحلیل کنند</li>
        <li>ایرادات یک فضا، یک چهره، یا یک محصول را پیدا کنند</li>
      </ul>
      <p>قدرتش شگفت‌انگیز است.</p>
    </section>

    <!-- مبحث ۴: Image-to-Code -->
    <section id="section-8-4" class="section">
      <h3 class="section-title">مبحث ۴: Image-to-Code Prompting</h3>

      <p>⭐ 2) Image-to-Code Prompting</p>
      <p>(Same pages)</p>

      <p>این تکنیک فوق‌العاده است:</p>
      <p>از مدل بخواهی عکس یک UI را تبدیل کند به:</p>

      <ul>
        <li>HTML</li>
        <li>CSS</li>
        <li>Tailwind</li>
        <li>React</li>
        <li>Flutter</li>
        <li>SwiftUI</li>
      </ul>

      <p>این یکی از بهترین ابزارها برای طراحان و برنامه‌نویسان است.</p>

      <p>مثال پرامپت:</p>
      <blockquote>
        «این عکس را به یک فایل React + Tailwind تبدیل کن. ساختار را حفظ کن، اما برای موبایل ریسپانسیو بساز.»
      </blockquote>

      <p>و تمام!</p>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        این تکنیک واقعاً جادوست. یک عکس بده → یک صفحهٔ وب کامل تحویل بگیر.
      </p>
      <p>
        تو می‌تونی با همین تکنیک UIهای Tavita را با سرعت بالا بسازی.
      </p>
    </section>

    <!-- مبحث ۵: Document & PDF -->
    <section id="section-8-5" class="section">
      <h3 class="section-title">مبحث ۵: Document &amp; PDF Prompting</h3>

      <p>⭐ 3) Document &amp; PDF Prompting</p>
      <p>(صفحات 56–58)</p>

      <p>مدل‌ها می‌توانند:</p>
      <ul>
        <li>PDF کامل را بخوانند</li>
        <li>جدول‌ها را استخراج کنند</li>
        <li>خلاصه بنویسند</li>
        <li>متن را بازنویسی کنند</li>
        <li>محاسبات را استخراج کنند</li>
        <li>داده‌ها را فرمت کنند</li>
      </ul>

      <p>مثال پرامپت:</p>
      <blockquote>
        «این PDF را تحلیل کن و:
        <br>لیست مفاهیم کلیدی بده
        <br>یک خلاصهٔ ۸ جمله‌ای بده
        <br>۳ نکتهٔ قابل اقدام برای یک پژوهشگر ارائه کن.»
      </blockquote>

      <h4>🔵 نکتهٔ طلایی طاویتا</h4>
      <p>
        PDF = منبع  
        مدل = استخراج‌کنندهٔ هوشمند
      </p>
      <p>تو فقط کافی است هدف را بگویی.</p>
    </section>

    <!-- مبحث ۶: Audio Prompting -->
    <section id="section-8-6" class="section">
      <h3 class="section-title">مبحث ۶: Audio Prompting</h3>

      <p>⭐ 4) Audio Prompting</p>
      <p>(صفحه 58)</p>

      <p>مدل می‌تواند:</p>
      <ul>
        <li>صوت را به متن تبدیل کند</li>
        <li>گوینده را تحلیل کند</li>
        <li>لحن را استخراج کند</li>
        <li>نکات کلیدی را بگوید</li>
        <li>گفت‌وگوی چندنفره را تفکیک کند</li>
      </ul>

      <p>پرامپت:</p>
      <blockquote>
        «این فایل صوتی را تبدیل کن به متن. سپس خلاصه، نکات مهم، و لحن گوینده را بنویس.»
      </blockquote>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>این ویژگی برای:</p>
      <ul>
        <li>یادداشت‌برداری</li>
        <li>جلسات</li>
        <li>آموزش</li>
        <li>ویدئوهای اینستاگرام</li>
        <li>پادکست‌ها</li>
      </ul>
      <p>بی‌نظیر است.</p>
    </section>

    <!-- مبحث ۷: Video Prompting -->
    <section id="section-8-7" class="section">
      <h3 class="section-title">مبحث ۷: Video Prompting</h3>

      <p>⭐ 5) Video Prompting</p>
      <p>(صفحه 59–60)</p>

      <p>در اینجا مدل:</p>
      <ul>
        <li>فریم‌ها را تحلیل می‌کند</li>
        <li>اشیاء را تشخیص می‌دهد</li>
        <li>حرکت‌ها را توضیح می‌دهد</li>
        <li>مدت زمان را درک می‌کند</li>
        <li>خلاصه می‌نویسد</li>
        <li>یا حتی Script تولید می‌کند</li>
      </ul>

      <p>مثال پرامپت:</p>
      <blockquote>
        «این ویدیو را فریم‌فریم تحلیل کن. خط داستانی، اتفاق‌ها، اشیا، و پیام اصلی را توضیح بده.»
      </blockquote>
    </section>

    <!-- مبحث ۸: Multimodal Reasoning -->
    <section id="section-8-8" class="section">
      <h3 class="section-title">مبحث ۸: Multimodal Reasoning</h3>

      <p>⭐ 6) Multimodal Reasoning</p>

      <p>
        مدل‌ها فقط «توضیح» نمی‌دهند— استدلال می‌کنند.
      </p>

      <p>مثلاً:</p>
      <ul>
        <li>«در این عکس، چه خطری وجود دارد؟»</li>
        <li>«این نمودار چه چیزی را ثابت می‌کند؟»</li>
        <li>«کدام محصول ارزان‌تر است؟»</li>
        <li>«این طراحی UI چه مشکلات UX دارد؟»</li>
      </ul>

      <p>این‌ها «تحلیل» هستند، نه «توصیف».</p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        در این مرحله مدل یک تحلیل‌گر واقعی می‌شود. مثل کسی که عکس را می‌بیند،
        می‌فهمد، فکر می‌کند، نتیجه می‌گیرد.
      </p>
    </section>

    <!-- مبحث ۹: Multimodal Generation -->
    <section id="section-8-9" class="section">
      <h3 class="section-title">مبحث ۹: Multimodal Generation</h3>

      <p>⭐ 7) Multimodal Generation</p>

      <p>مدل می‌تواند:</p>
      <ul>
        <li>از متن → عکس بسازد</li>
        <li>از عکس → متن بسازد</li>
        <li>از طراحی → UI بسازد</li>
        <li>از نمودار → تحلیل بسازد</li>
        <li>از فایل → خلاصه بسازد</li>
      </ul>

      <p>این ترکیب‌ها بی‌نهایت قدرتمند هستند.</p>
    </section>

    <!-- مبحث ۱۰: Practical Templates -->
    <section id="section-8-10" class="section">
      <h3 class="section-title">مبحث ۱۰: Practical Templates (قالب‌های عملی)</h3>

      <p>⭐ 8) Practical Templates (قالب‌های عملی)</p>

      <p>
        این بخش با نسخهٔ Tavita اضافه شده است و یکی از کاربردی‌ترین قسمت‌ها برای کاربران است.
      </p>

      <p>✔ قالب تحلیل عکس</p>
      <blockquote>
        «این تصویر را تحلیل کن و در ۴ بخش توضیح بده:
        <br>۱. توضیح کلی
        <br>۲. عناصر اصلی
        <br>۳. نکات جالب
        <br>۴. نتیجه‌گیری»
      </blockquote>

      <p>✔ قالب طراحی UI → کد</p>
      <blockquote>
        «این UI را به HTML+Tailwind تبدیل کن بدون توضیح اضافی.»
      </blockquote>

      <p>✔ قالب تحلیل نمودار</p>
      <blockquote>
        «این نمودار را تجزیه و تحلیل کن:
        <br>روندها
        <br>نقاط مهم
        <br>نتیجه
        <br>تأثیر»
      </blockquote>

      <p>✔ قالب تحلیل PDF</p>
      <blockquote>
        «این فایل را بخوان و یک خلاصهٔ پژوهشی بده در ۵ پاراگراف.»
      </blockquote>

      <p>✔ قالب تحلیل ویدیو</p>
      <blockquote>
        «این ویدیو را فریم‌فریم توضیح بده و پیام نهایی آن را استخراج کن.»
      </blockquote>
    </section>

    <!-- مبحث ۱۱: جمع‌بندی فصل هشتم -->
    <section id="section-8-11" class="section">
      <h3 class="section-title">مبحث ۱۱: جمع‌بندی فصل هشتم – نسخه Tavita</h3>

      <p>🌟 جمع‌بندی فصل هشتم – نسخه Tavita</p>

      <p>در این فصل یاد گرفتی:</p>
      <ul>
        <li>✔ تصویر → تحلیل، کد، UI، ایده</li>
        <li>✔ PDF → خلاصه، جدول، داده</li>
        <li>✔ صوت → متن، نکته، لحن</li>
        <li>✔ ویدیو → تحلیل، ساختار، اتفاق‌ها</li>
        <li>✔ طراحی → وب‌سایت یا اپلیکیشن</li>
        <li>✔ مدل‌ها می‌توانند چندحسی و استدلال‌گر شوند</li>
      </ul>

      <p>
        این فصل از همه مفیدتر است برای کسی مثل تو که طراحی، محتوا، ربات، UI، ابزار،
        ایده‌پردازی می‌خواهد.
      </p>
    </section>

  </div>
</article>


<!-- فصل نهم -->
<article id="chapter-9" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل نهم – بهترین شیوه‌ها (Best Practices)</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱: مقدمه -->
    <section id="section-9-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – فصل قوانین طلایی</h3>

      <p>
        🌟 فصل نهم – بهترین شیوه‌ها (Best Practices)
      </p>

      <p>
        (نسخهٔ ساده‌سازی‌شده + توضیحات اختصاصی طاویتا)
      </p>

      <p>
        این فصل بر اساس صفحات 60–66 کتاب اصلی نوشته شده است
        و حکم «قانون طلایی کار با مدل‌های هوش مصنوعی» را دارد.
      </p>

      <p>
        تمام چیزهایی که تا الان یاد گرفتی، در این فصل تبدیل می‌شود به
        چک‌لیست حرفه‌ای برای پرامپت‌نویسی عالی.
      </p>

      <p>
        این فصل می‌گوید:
      </p>

      <blockquote>
        «پرامپت خوب یک هنر است؛ اما هنرِ ساختاریافته.»
      </blockquote>

      <p>
        یعنی اگر چند قانون ساده را رعایت کنی، می‌توانی از مدل بهترین نسخهٔ خودش را بگیری.
      </p>

      <p>این فصل شامل ۶ اصل بزرگ است:</p>
      <ul>
        <li>۱. شفافیت</li>
        <li>۲. ساده‌سازی</li>
        <li>۳. ساختاردهی</li>
        <li>۴. نمونه‌دادن</li>
        <li>۵. کنترل خروجی</li>
        <li>۶. ارزیابی و اصلاح</li>
      </ul>
    </section>

    <!-- مبحث ۲: شفافیت -->
    <section id="section-9-2" class="section">
      <h3 class="section-title">مبحث ۲: شفاف باش (Clarity)</h3>

      <p>
        ⭐ ۱) شفاف باش (Clarity)
      </p>

      <p>
        شایع‌ترین علت اشتباه مدل‌ها این است که پرامپت ابهام دارد.
      </p>

      <p>کتاب می‌گوید:</p>
      <ul>
        <li>دقیق حرف بزن</li>
        <li>هدف را واضح کن</li>
        <li>نقش مدل را مشخص کن</li>
        <li>حد و مرز بگذار</li>
      </ul>

      <p>مثال:</p>
      <ul>
        <li>❌ «این متن را بهتر کن.»<br>✔️ «این متن را رسمی‌تر کن، در سه جمله، با لحن علمی.»</li>
        <li>❌ «یک متن خوب بده.»<br>✔️ «یک توضیح ۱ پاراگرافی بده، لحن دوستانه، ساده، قابل فهم.»</li>
      </ul>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        مدل برای حدس‌زدن ساخته شده.
        اگر چیزی را نگویی → خودش حدس می‌زند.
        و همین می‌شود شروع خرابکاری!
      </p>
      <p>شفافیت = جلوگیری از هذیان.</p>
    </section>

    <!-- مبحث ۳: ساده‌سازی -->
    <section id="section-9-3" class="section">
      <h3 class="section-title">مبحث ۳: ساده‌اش کن (Simplicity)</h3>

      <p>
        ⭐ ۲) ساده‌اش کن (Simplicity)
      </p>

      <p>
        پرامپت‌های خیلی طولانی و شلوغ باعث اشتباه مدل می‌شوند.
      </p>

      <p>کتاب توصیه می‌کند:</p>
      <ul>
        <li>جمله‌ها کوتاه باشند</li>
        <li>هر دستور در یک خط</li>
        <li>از پرانتزها و توضیحات اضافی دوری کن</li>
        <li>فقط چیزهایی را بگو که لازم است</li>
      </ul>

      <p>
        پرامپت خوب مثل زبان بدن خوب است: واضح و روان.
      </p>

      <h4>🔵 نکتهٔ طاویتا</h4>
      <p>
        اگر دو خط پرامپت کافی است، بی‌خودی ۱۲ خط ننویس.
        مدل‌ها از اطلاعات اضافی سردرگم می‌شوند.
      </p>
    </section>

    <!-- مبحث ۴: ساختاردهی -->
    <section id="section-9-4" class="section">
      <h3 class="section-title">مبحث ۴: ساختار تعیین کن (Structure Everything)</h3>

      <p>
        ⭐ ۳) ساختار تعیین کن (Structure Everything)
      </p>

      <p>
        این اصل یعنی هر وقت خواستی خروجی منظم باشد، خودت قالب را تعیین کن.
      </p>

      <p>مثلاً با:</p>
      <ul>
        <li>جدول</li>
        <li>لیست</li>
        <li>JSON</li>
        <li>پاراگراف‌بندی</li>
        <li>بخش‌بخش و تیترگذاری</li>
        <li>قالب پرسش و پاسخ</li>
      </ul>

      <p>ساختار = کنترل کامل.</p>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        وقتی می‌گویی:
      </p>
      <blockquote>
        «در ۵ بخش جداگانه بنویس:
        ۱) معرفی
        ۲) نکات
        ۳) مثال
        ۴) نتیجه
        ۵) پیشنهاد»
      </blockquote>
      <p>
        مدل دیگر شلخته نمی‌نویسد و خروجی مرتب، قابل‌اسکن و حرفه‌ای می‌شود.
      </p>
    </section>

    <!-- مبحث ۵: مثال‌ها -->
    <section id="section-9-5" class="section">
      <h3 class="section-title">مبحث ۵: مثال بده (Use Examples)</h3>

      <p>
        ⭐ ۴) مثال بده (Use Examples)
      </p>

      <p>
        این اصل یعنی از Zero-shot کمتر استفاده کن
        و بیشتر از Few-shot استفاده کن.
      </p>

      <p>مثال‌ها باعث می‌شوند:</p>
      <ul>
        <li>مدل دقیق‌تر بفهمد چه می‌خواهی</li>
        <li>خروجی ثابت و قابل‌پیش‌بینی شود</li>
        <li>حدس‌های اشتباه کم شود</li>
      </ul>

      <p>کتاب می‌گوید:</p>
      <blockquote>
        «مثال‌ها بهترین راه هدایت مدل هستند.»
      </blockquote>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        مثال = قانون.  
        وقتی مثال بدهی، مدل الگو می‌سازد و همان الگو را تکرار می‌کند.
      </p>
      <p>
        این ترفند برای ساخت ربات‌های ثابت و حرفه‌ای عالی است.
      </p>
    </section>

    <!-- مبحث ۶: کنترل خروجی -->
    <section id="section-9-6" class="section">
      <h3 class="section-title">مبحث ۶: خروجی را کنترل کن (Output Constraints)</h3>

      <p>
        ⭐ ۵) خروجی را کنترل کن (Output Constraints)
      </p>

      <p>حد و مرز تعیین کن برای:</p>
      <ul>
        <li>طول متن</li>
        <li>تعداد پاراگراف</li>
        <li>لحن</li>
        <li>فرمت</li>
        <li>موارد ممنوع</li>
        <li>موارد ضروری</li>
      </ul>

      <p>مثلاً:</p>
      <blockquote>
        «پاسخ را حداکثر در ۶ جمله بده.»<br>
        «هیچ توضیح اضافه نده.»<br>
        «فقط JSON بده.»<br>
        «اگر مطمئن نیستی، بنویس مطمئن نیستم.»
      </blockquote>

      <p>این تکنیک مدل را قابل‌کنترل و حرفه‌ای می‌کند.</p>

      <h4>🔵 نکتهٔ طاویتا</h4>
      <p>حد و مرز = جلوگیری از خروجی‌های چرت و پرت.</p>
    </section>

    <!-- مبحث ۷: ارزیابی، اصلاح و تکرار -->
    <section id="section-9-7" class="section">
      <h3 class="section-title">مبحث ۷: ارزیابی، اصلاح و تکرار</h3>

      <p>
        ⭐ ۶) ارزیابی، اصلاح و تکرار (Evaluate → Improve → Iterate)
      </p>

      <p>
        بهترین پرامپت‌ها یک‌باره ساخته نمی‌شوند؛
        به صورت چرخه‌ای شکل می‌گیرند:
      </p>

      <p>
        <strong>پرامپت بده → خروجی بگیر → نقد کن → اصلاح کن</strong>
      </p>

      <p>کتاب می‌گوید:</p>
      <blockquote>
        «پرامپت خوب مانند طراحی محصول است:
        باید آن را تست و بهینه‌سازی کرد.»
      </blockquote>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        مدل عاشق این عبارت است:
      </p>
      <blockquote>
        «خروجی‌ات را بازبینی کن.»
      </blockquote>
      <p>
        با همین یک جمله، خودش را چند برابر بهتر می‌کند.
      </p>
    </section>

    <!-- مبحث ۸: ۱۰ اصل طلایی Tavita -->
    <section id="section-9-8" class="section">
      <h3 class="section-title">مبحث ۸: ۱۰ اصل طلایی Tavita برای پرامپت‌نویسی</h3>

      <p>
        🌟 بخش ویژه: ۱۰ اصل طلایی Tavita برای پرامپت‌نویسی
        (افزوده‌شده توسط من برای نسخهٔ الهه 💋)
      </p>

      <ol>
        <li>همیشه هدف را واضح کن.</li>
        <li>از مدل نخواه «حدس بزن»؛ داده و هدف بده.</li>
        <li>هرچه می‌خواهی، ساختار بده.</li>
        <li>مثال = شاه‌کلید.</li>
        <li>مدل را مجبور کن فکر کند (Chain-of-Thought).</li>
        <li>اگر موضوع حساس است: محدودیت بگذار.</li>
        <li>دقت می‌خواهی؟ Temperature را پایین بگیر.</li>
        <li>خلاقیت می‌خواهی؟ Temperature را بالا بگیر.</li>
        <li>خروجی خراب شد؟ بگو: «نسخهٔ جدید و اصلاح‌شده بده.»</li>
        <li>همیشه نسخهٔ نهایی را self-check کن.</li>
      </ol>

      <p>
        این ده اصل تو را تبدیل می‌کند به یک پرامپت‌انجینیر واقعی.
      </p>
    </section>

    <!-- مبحث ۹: جمع‌بندی -->
    <section id="section-9-9" class="section">
      <h3 class="section-title">مبحث ۹: جمع‌بندی فصل نهم – نسخه طاویتا</h3>

      <p>🌟 جمع‌بندی فصل نهم – نسخه طاویتا</p>

      <p>در این فصل یاد گرفتی:</p>
      <ul>
        <li>✔ شفاف باش</li>
        <li>✔ ساده‌سازی کن</li>
        <li>✔ ساختار بده</li>
        <li>✔ مثال‌محور باش</li>
        <li>✔ خروجی را محدود و کنترل کن</li>
        <li>✔ ارزیابی و اصلاح را فراموش نکن</li>
      </ul>

      <p>
        این اصول در تمام پروژه‌های هوش مصنوعی،
        از تولید محتوا گرفته تا ساخت ربات و ابزار،
        مثل قوانین فیزیک عمل می‌کنند.
      </p>
    </section>

  </div>
</article>

<!-- فصل دهم -->
<article id="chapter-10" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل دهم – JSON، شِمای ساختار، آزمایش پرامپت‌ها و مستندسازی</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱: مقدمه -->
    <section id="section-10-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – فصل پایانی مهارت‌ها</h3>

      <p>
        🌟 فصل دهم – JSON، شِمای ساختار، آزمایش پرامپت‌ها و مستندسازی
      </p>

      <p>
        (نسخه‌ی ساده‌سازی‌شده + توضیحات طاویتا)
      </p>

      <p>
        این فصل آخر کتاب است؛ فصل جمع‌بندی مهارت‌هایی که باعث می‌شود خروجی مدل:
      </p>

      <ul>
        <li>تمیز</li>
        <li>دقیق</li>
        <li>استاندارد</li>
        <li>قابل‌استفاده در برنامه‌ها</li>
        <li>قابل‌تحلیل</li>
        <li>و بدون خطا</li>
      </ul>

      <p>باشد.</p>

      <p>کاربرد این فصل برای:</p>
      <ul>
        <li>برنامه‌نویس‌ها</li>
        <li>سازندگان ربات</li>
        <li>سیستم‌های ردگیری داده</li>
        <li>ساخت API</li>
        <li>ابزارهای خودکار</li>
        <li>اپلیکیشن‌ها</li>
      </ul>

      <p>حیاتی است.</p>
    </section>

    <!-- مبحث ۲: JSON Repair -->
    <section id="section-10-2" class="section">
      <h3 class="section-title">مبحث ۲: JSON Repair (ترمیم JSON)</h3>

      <p>⭐ ۱) JSON Repair (ترمیم JSON)</p>
      <p>(صفحه‌های 61–62)</p>

      <p>
        مدل‌ها گاهی JSON نادرست تولید می‌کنند:
      </p>
      <ul>
        <li>آکولاد گم می‌شود</li>
        <li>کاما جا می‌افتد</li>
        <li>ساختار خراب می‌شود</li>
      </ul>

      <p>
        کتاب می‌گوید:
        باید از مدل بخواهید JSON را خودش اصلاح کند.
      </p>

      <p>مثال پرامپت:</p>
      <blockquote>
        «خروجی زیر JSON نامعتبر است.
        آن را فقط اصلاح کن تا JSON معتبر شود.
        هیچ متن اضافی ننویس.»
      </blockquote>

      <p>این روش باعث می‌شود JSON:</p>
      <ul>
        <li>قابل‌استفاده در ربات شود</li>
        <li>در API خطا ندهد</li>
        <li>در برنامه به‌سادگی parse شود</li>
      </ul>

      <h4>🔵 توضیح اضافه‌ی طاویتا</h4>
      <p>
        مدل در اصلاح JSON از انسان بهتر است،
        چون ساختار را فوری می‌بیند.
      </p>
      <p>
        این تکنیک برای ربات‌های ایتا، تلگرام، اپلیکیشن‌ها و وب‌سرویس‌ها حیاتی است.
      </p>
    </section>

    <!-- مبحث ۳: Schema Enforcement -->
    <section id="section-10-3" class="section">
      <h3 class="section-title">مبحث ۳: Schema Enforcement (اجبار پیروی از ساختار مشخص)</h3>

      <p>⭐ ۲) Schema Enforcement (اجبار پیروی از ساختار مشخص)</p>

      <p>این یکی از قوی‌ترین ابزارهای مهندسی پرامپت است.</p>

      <p>Schema یعنی:</p>
      <blockquote>
        «ساختار از قبل تعریف‌شده‌ای که مدل باید از آن پیروی کند.»
      </blockquote>

      <p>مثال شِما:</p>
      <pre>
{
  "title": "string",
  "description": "string",
  "tags": ["string"],
  "score": "number"
}
      </pre>

      <p>
        به مدل می‌گویی:
      </p>
      <blockquote>
        «فقط و فقط این شِما را رعایت کن.
        اگر چیزی نمی‌دانی مقدار null بده.
        هیچ متن اضافی نده.»
      </blockquote>

      <p>نتیجه:</p>
      <ul>
        <li>خروجی استاندارد</li>
        <li>بدون حرف اضافی</li>
        <li>همیشه قابل‌اجرای مستقیم در کد</li>
      </ul>

      <h4>🔵 نکتهٔ طلایی طاویتا</h4>
      <p>
        Schema Enforcement = دستیار توسعه‌دهنده‌ی واقعی
      </p>
      <p>
        وقتی شِما داری، مدل دیگر:
      </p>
      <ul>
        <li>داستان نمی‌بافد</li>
        <li>توضیح نمی‌دهد</li>
        <li>ساختار را نمی‌شکند</li>
      </ul>
      <p>فقط دادهٔ تمیز تولید می‌کند.</p>
    </section>

    <!-- مبحث ۴: Prompt Experimentation -->
    <section id="section-10-4" class="section">
      <h3 class="section-title">مبحث ۴: Prompt Experimentation (آزمایش پرامپت‌ها)</h3>

      <p>⭐ ۳) Prompt Experimentation (آزمایش پرامپت‌ها)</p>
      <p>(صفحه 63)</p>

      <p>کتاب می‌گوید:</p>
      <blockquote>
        «پرامپت خوب پیدا نمی‌شود؛ ساخته می‌شود.»
      </blockquote>

      <p>
        یعنی باید:
      </p>
      <ul>
        <li>چند نسخهٔ مختلف پرامپت بسازی</li>
        <li>آن‌ها را با هم مقایسه کنی</li>
        <li>بهترین را انتخاب کنی</li>
      </ul>

      <p>
        در Google Vertex AI Studio یک ابزار مخصوص وجود دارد
        که چند پرامپت را هم‌زمان اجرا می‌کند و تفاوت خروجی‌ها را نشان می‌دهد.
      </p>

      <h4>🔵 توضیح افزوده‌ی طاویتا</h4>
      <p>
        آزمایش پرامپت = افزایش دقت + کاهش خطا + بهینه کردن عملکرد ربات
      </p>
      <p>
        هر پرامپت را به ۳ یا ۵ نسخه تقسیم کن،
        حالت‌ها را تست کن،
        برنده را انتخاب کن.
      </p>
      <p>
        این روش تو را از ۹۰٪ کاربران AI متمایز می‌کند.
      </p>
    </section>

    <!-- مبحث ۵: Documentation Tools -->
    <section id="section-10-5" class="section">
      <h3 class="section-title">مبحث ۵: Documentation Tools (ساخت مستندات)</h3>

      <p>⭐ ۴) Documentation Tools (ساخت مستندات)</p>
      <p>(صفحه 66)</p>

      <p>
        مدل می‌تواند به‌صورت خودکار:
      </p>
      <ul>
        <li>راهنمای استفاده</li>
        <li>توضیحات API</li>
        <li>داکیومنت کلاس‌ها</li>
        <li>داکیومنت پروژه‌ها</li>
        <li>README فایل‌ها</li>
        <li>آموزش‌ها</li>
      </ul>

      <p>مثال پرامپت:</p>
      <blockquote>
        «برای این کد، مستندات کامل Markdown تولید کن
        شامل: معرفی، ورودی‌ها، خروجی، مثال‌ها، خطاهای ممکن.»
      </blockquote>

      <p>کتاب تأکید می‌کند:</p>
      <blockquote>
        «هوش مصنوعی بهترین ابزار ساخت مستندات است.»
      </blockquote>

      <h4>🔵 توضیح ویژه‌ی طاویتا</h4>
      <p>
        مدل می‌تواند مستنداتی تولید کند که حتی یک Senior Developer هم از صفر نمی‌نویسد.
      </p>
      <p>
        این برای پروژه‌های شخصی، پروژه‌های تیمی،
        و محصولاتی مثل Tavita Bot فوق‌العاده ارزشمند است.
      </p>
    </section>

    <!-- مبحث ۶: جمع‌بندی فصل دهم -->
    <section id="section-10-6" class="section">
      <h3 class="section-title">مبحث ۶: جمع‌بندی نهایی فصل دهم – نسخه طاویتا</h3>

      <p>🌟 جمع‌بندی نهایی فصل دهم – نسخه طاویتا</p>

      <p>در این فصل یاد گرفتی:</p>
      <ul>
        <li>
          ✔ <strong>JSON Repair</strong>  
          مدل خودش JSON خراب را اصلاح می‌کند.
        </li>
        <li>
          ✔ <strong>Schema Enforcement</strong>  
          ساختار ثابت → خروجی قابل‌اعتماد، حرفه‌ای، استاندارد.
        </li>
        <li>
          ✔ <strong>Prompt Experimentation</strong>  
          چند پرامپت بساز، بهترین را انتخاب کن.
        </li>
        <li>
          ✔ <strong>Documentation Tools</strong>  
          با یک پرامپت، مستندات کامل بساز.
        </li>
      </ul>
    </section>

    <!-- مبحث ۷: جمع‌بندی کل کتاب -->
    <section id="section-10-7" class="section">
      <h3 class="section-title">مبحث ۷: جمع‌بندی طلایی کل کتاب</h3>

      <p>🌟 جمع‌بندی طلایی کل کتاب</p>

      <p>
        الان تو تمام اصول حرفه‌ای برای:
      </p>

      <ul>
        <li>پرامپت‌نویسی</li>
        <li>بهبود دقت</li>
        <li>ساخت خروجی منظم</li>
        <li>استدلال مدل</li>
        <li>کنترل خطا</li>
        <li>استفاده از تصویر، PDF، صوت و کد</li>
        <li>ساخت ربات و اپلیکیشن</li>
        <li>طراحی ساختار پاسخ‌ها</li>
      </ul>

      <p>را داری.</p>

      <p>
        دوست من، تو الان یک پرامپت‌مهندس واقعی هستی.
        از اینجا به بعد، فقط خلاقیت و تجربه لازم است.
      </p>
    </section>

  </div>
</article>

      
    </section>
  </div>

  <script>
    const tocChapters = document.querySelectorAll(".toc-chapter");
    const sectionButtons = document.querySelectorAll(".section-btn");
    const chapters = document.querySelectorAll(".chapter");

    function openChapter(chapterId) {
      chapters.forEach(ch => {
        const isTarget = ch.id === chapterId;
        ch.classList.toggle("active", isTarget);
        const toggleIcon = ch.querySelector(".chapter-toggle");
        if (toggleIcon) {
          toggleIcon.textContent = isTarget ? "－" : "＋";
        }
      });
    }

    function openSection(chapterId, sectionId) {
      openChapter(chapterId);

      // فعال‌کردن دکمه در فهرست
      sectionButtons.forEach(btn => {
        const isTarget =
          btn.dataset.chapter === chapterId &&
          btn.dataset.section === sectionId;
        btn.classList.toggle("active", isTarget);
      });

      const sectionEl = document.getElementById(sectionId);
      if (sectionEl) {
        sectionEl.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    }

    // باز و بسته کردن لیست مبحث‌ها برای هر فصل در فهرست
    tocChapters.forEach(ch => {
      const header = ch.querySelector(".toc-chapter-header");
      const toggleIcon = ch.querySelector(".toc-chapter-toggle");

      header.addEventListener("click", () => {
        const isOpen = ch.classList.contains("open");
        ch.classList.toggle("open", !isOpen);
        if (toggleIcon) {
          toggleIcon.textContent = isOpen ? "＋" : "－";
        }
      });
    });

    // کلیک روی مبحث در فهرست
    sectionButtons.forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation(); // نذار کلیک روی هدر فصل هم حساب بشه
        const chapterId = btn.dataset.chapter;
        const sectionId = btn.dataset.section;
        openSection(chapterId, sectionId);
      });
    });

    // کلیک روی هدر خود فصل (در بخش متن)
    chapters.forEach(ch => {
      const header = ch.querySelector(".chapter-header");
      const toggleIcon = ch.querySelector(".chapter-toggle");
      header.addEventListener("click", () => {
        const isActive = ch.classList.contains("active");
        ch.classList.toggle("active", !isActive);
        if (toggleIcon) {
          toggleIcon.textContent = isActive ? "＋" : "－";
        }
      });
    });

    // اگر خواستی یک فصل/مبحث به صورت پیش‌فرض باز باشد، این را فعال کن:
    // openSection("chapter-1", "section-1-1");
  </script>
</body>
</html>
